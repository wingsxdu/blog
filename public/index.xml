<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>beihai</title>
    <link>https://www.wingsxdu.com/</link>
    <description>Recent content on beihai</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 29 Sep 2019 17:20:37 +0800</lastBuildDate>
    
        <atom:link href="https://www.wingsxdu.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>欢迎来到北海的博客</title>
      <link>https://www.wingsxdu.com/about/</link>
      <pubDate>Thu, 06 Sep 2018 13:22:47 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/about/</guid>
      
        <description>

&lt;p style=&#34;text-align: center;&#34;&gt;
  &lt;strong&gt;关于博主&lt;/strong&gt;
&lt;/p&gt;

&lt;p&gt;Gopher，电子产品爱好者，Software Developer，&lt;/p&gt;

&lt;p&gt;西电2017级本科生，非 IT 专业，目前研究方向为微服务与分布式&lt;/p&gt;

&lt;p&gt;不喜欢国内大学的授课内容与教学方式，家境贫寒，一身本事全凭自学&lt;/p&gt;

&lt;p&gt;技术栈：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Golang back-end &amp;amp; database：gin、echo、gorm&lt;/li&gt;
&lt;li&gt;区块链相关开发&lt;/li&gt;
&lt;li&gt;Ant Design、Android APP、微信小程序等&lt;/li&gt;
&lt;li&gt;爬虫、机器学习、算法略有接触&lt;/li&gt;
&lt;li&gt;996经验丰富 🙂&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;喜欢穷游与经营类游戏，热爱音乐、电影与艺术表演；&lt;/p&gt;

&lt;h4 id=&#34;个人总结&#34;&gt;个人总结&lt;/h4&gt;

&lt;h5 id=&#34;golang&#34;&gt;Golang&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Web：gin、echo&lt;/li&gt;
&lt;li&gt;orm ：gorm、xorm&lt;/li&gt;
&lt;li&gt;rpc：gprc、 protobuf&lt;/li&gt;
&lt;li&gt;其他工具包&lt;/li&gt;
&lt;li&gt;底层、并发、编译器&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;书籍&#34;&gt;书籍&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Go 语言初学：：&lt;a href=&#34;https://tour.go-zh.org/welcome/1&#34;&gt;A tour of go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go 语言入门：&lt;a href=&#34;https://books.studygolang.com/gopl-zh/&#34;&gt;The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go 语言进阶：&lt;a href=&#34;https://chai2010.cn/advanced-go-programming-book&#34;&gt;Go 语言高级编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《三体》&lt;/li&gt;
&lt;li&gt;《文化苦旅》、《活着》、《平凡的世界》&lt;/li&gt;
&lt;li&gt;《下一个倒下的会不会是华为》&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;设备&#34;&gt;设备&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;笔记本：HP Spectre X360 2019（打算入个英特尔NUC）&lt;/li&gt;
&lt;li&gt;游戏机：Xbox One X&lt;/li&gt;
&lt;li&gt;键盘：massdrop CTRL&lt;/li&gt;
&lt;li&gt;移动硬盘：华为备咖存储&lt;/li&gt;
&lt;li&gt;耳机：森海塞尔 IE80S、赛睿 X100&lt;/li&gt;
&lt;li&gt;屏幕：LG 29UM59A 21:9（打算换掉了）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;工具&#34;&gt;工具&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;IDE：主 Goland + 辅  VS Code&lt;/li&gt;
&lt;li&gt;Markdown 编辑器：Typora&lt;/li&gt;
&lt;li&gt;娱乐：网易云音乐UWP&lt;/li&gt;
&lt;li&gt;HTTP 代理：&lt;a href=&#34;https://github.com/wingsxdu/blogServer&#34;&gt;自己写了一个简单的http代理返回静态文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>并发编程与 Goroutine 调度</title>
      <link>https://www.wingsxdu.com/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E-goroutine-%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Sun, 29 Sep 2019 17:20:37 +0800</pubDate>
      
      <guid>https://www.wingsxdu.com/post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E-goroutine-%E8%B0%83%E5%BA%A6/</guid>
      
        <description>

&lt;h4 id=&#34;并发与并行&#34;&gt;并发与并行&lt;/h4&gt;

&lt;p&gt;并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生。&lt;/p&gt;

&lt;p&gt;并行是在不同实体上的多个事件，在多台处理器上同时处理多个任务。并发是在同一实体上的多个事件,在一台处理器上“同时”处理多个任务。&lt;/p&gt;

&lt;p&gt;并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。&lt;/p&gt;

&lt;p&gt;并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。&lt;/p&gt;

&lt;h4 id=&#34;协程-线程-进程的区别&#34;&gt;协程，线程，进程的区别。&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间主要通过共享内存通信，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，因为是直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。&lt;/p&gt;

&lt;h4 id=&#34;goroutine-调度&#34;&gt;Goroutine 调度&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING.
“不要通过共享内存来通信，而应通过通信来共享内存。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;goroutine&#34;&gt;Goroutine&lt;/h6&gt;

&lt;p&gt;Goroutine，Go语言基于并发（并行）编程给出的解决方案。通常 goroutine 会被当做 coroutine（协程）的 golang 实现，从比较粗浅的层面来看，这种认知也算是合理。但实际上，goroutine并非传统意义上的协程，现在主流的线程模型分三种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），传统的协程库属于&lt;strong&gt;用户级线程模型&lt;/strong&gt;，而 goroutine 和它的&lt;code&gt;Go Scheduler&lt;/code&gt;在底层实现上其实是属于&lt;strong&gt;两级线程模型&lt;/strong&gt;，因此，有时候为了方便理解可以简单把goroutine类比成协程，但一定要有个清晰的认知——goroutine并不等同于协程。&lt;/p&gt;

&lt;p&gt;goroutine使用方式非常的简单，只需使用 &lt;code&gt;go&lt;/code&gt; 关键字即可启动一个协程，并且它是处于异步方式运行，你不需要等它运行完成以后在执行以后的代码。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go func() // 通过go关键字启动一个协程来运行函数&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Go的调度器内部有四个重要的结构：M，P，S，Sched，如上图所示（Sched 未给出）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;G：表示 Goroutine，每个 Goroutine 对应一个G结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个 G 需要绑定到 P 才能被调度执行。&lt;/li&gt;
&lt;li&gt;P： Processor，表示逻辑处理器。 对G来说，P 相当于 CPU 核，G 只有绑定到 P （在 P 的 local  队列中）才能被调度。对 M 来说，P 提供了相关的执行环境（Context），如内存分配状态（mcache），任务队列（G）等， P的数量决定了系统内最大可并行的 G 的数量（前提：物理CPU核数 &amp;gt;= P 的数量），P 的数量由用户设置的 GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P的数量最大为256。&lt;/li&gt;
&lt;li&gt;M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为10000个。&lt;/li&gt;
&lt;li&gt;Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/image/goroutine1.jpg&#34; alt=&#34;goroutine1&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;g-p-m-模型调度&#34;&gt;G-P-M 模型调度&lt;/h6&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/image/goroutine-scheduler-model.png&#34; alt=&#34;goroutine-scheduler-model&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Go 调度器工作时会维护两种用来保存 G 的任务队列：一种是一个 Global 任务队列，一种是每个 P 维护的 Local 任务队列。&lt;/p&gt;

&lt;p&gt;当通过&lt;code&gt;go&lt;/code&gt;关键字创建一个新的 goroutine 的时候，它会优先被放入P 的本地队列。为了运行goroutine，M 需要持有（绑定）一个 P，接着M会启动一个 OS线程，循环从P的本地队列里取出一个 goroutine 并执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/image/goroutine2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上图中可以看到，有2个物理线程M，每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。&lt;/p&gt;

&lt;p&gt;除此之外还有 &lt;code&gt;work-stealing&lt;/code&gt;调度算法：当 M 执行完了当前 P 的 Local 队列里的所有 G 后，P 也不会就这么在那躺尸啥都不干，它会先尝试从 Global 队列寻找 G 来执行，如果 Global队列为空，它会随机挑选另外一个 P，从它的队列里中拿走一半的 G 到自己的队列中执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/image/goroutine3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;为什么要有-p-processor&#34;&gt;为什么要有 P(Processor) ？&lt;/h4&gt;

&lt;p&gt;你可能会想，为什么一定需要一个上下文，我们能不能直接除去上下文，让 &lt;code&gt;Goroutine&lt;/code&gt; 的 &lt;code&gt;runqueues&lt;/code&gt; 挂到M上呢？答案是不行，需要上下文的目的，是让我们可以直接放开其他线程，当遇到内核线程阻塞的时候。&lt;/p&gt;

&lt;p&gt;一个很简单的例子就是系统调用 &lt;code&gt;sysall&lt;/code&gt;，一个线程肯定不能同时执行代码和系统调用被阻塞，这个时候，此线程M需要放弃当前的上下文环境 P，以便可以让其他的 &lt;code&gt;Goroutine&lt;/code&gt; 被调度执行。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>GC 垃圾回收机制(改)</title>
      <link>https://www.wingsxdu.com/post/2019-09-29-gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Fri, 27 Sep 2019 21:42:49 +0800</pubDate>
      
      <guid>https://www.wingsxdu.com/post/2019-09-29-gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      
        <description>

&lt;p&gt;首先我们了解下什么是垃圾回收&lt;/p&gt;

&lt;p&gt;内存管理是开发应用中的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。&lt;/p&gt;

&lt;h4 id=&#34;过去常采用的两种内存管理方法&#34;&gt;过去常采用的两种内存管理方法&lt;/h4&gt;

&lt;h6 id=&#34;内存泄露检测工具&#34;&gt;内存泄露检测工具&lt;/h6&gt;

&lt;p&gt;这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然而检测工具难免有疏漏和不足，只能起到辅助作用。&lt;/p&gt;

&lt;h6 id=&#34;智能指针&#34;&gt;智能指针&lt;/h6&gt;

&lt;p&gt;这是 c++ 中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，使程序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是最广泛的做法，但是对程序开发者有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄露。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php 等等）都引入了语言层面的自动内存管理 ——也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。&lt;/p&gt;

&lt;h4 id=&#34;新生代语言常用的垃圾回收的方法&#34;&gt;新生代语言常用的垃圾回收的方法&lt;/h4&gt;

&lt;h6 id=&#34;1-引用计数-reference-counting&#34;&gt;1.引用计数（reference counting）&lt;/h6&gt;

&lt;p&gt;这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一，当引用计数为0时则立即回收对象。&lt;/p&gt;

&lt;p&gt;这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架、php、python等。&lt;/p&gt;

&lt;p&gt;但是简单引用计数算法也有明显的缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;频繁更新引用计数降低了性能：一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。除此之外还有很多其他方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;循环引用：当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如 cocoa 引入了 strong 指针和weak 指针两种指针类型。或者系统检测循环引用并主动打破循环链，当然这也增加了垃圾回收的复杂度。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;2-标记-清除-mark-and-sweep&#34;&gt;2.标记-清除（mark and sweep）&lt;/h6&gt;

&lt;p&gt;标记-清除（mark and sweep）分为两步，标记从根变量开始迭代遍历所有被引用的对象，对能够通过引用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收使系统响应能力大大降低！当然后续也出现了很多 mark&amp;amp;sweep 算法的变种（如三色标记法）优化了这个问题。&lt;/p&gt;

&lt;h6 id=&#34;3-分代搜集-generation&#34;&gt;3.分代搜集（generation）&lt;/h6&gt;

&lt;p&gt;java 的 jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这也是科学思考的一个基本思路）。&lt;/p&gt;

&lt;p&gt;因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。&lt;/p&gt;

&lt;h4 id=&#34;golang-gc-时会发生什么&#34;&gt;Golang GC 时会发生什么?&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Golang 1.5后，采取的是&lt;strong&gt;非分代的、非移动的、并发的、三色的&lt;/strong&gt;标记清除垃圾回收算法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;golang 中的 gc 基本上是标记清除的过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/gc.jpg&#34; alt=&#34;gc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;gc 的过程一共分为四个阶段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;栈扫描（开始时 STW）&lt;/li&gt;
&lt;li&gt;第一次标记（并发）&lt;/li&gt;
&lt;li&gt;第二次标记（STW）&lt;/li&gt;
&lt;li&gt;清除（并发）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先 STW(Stop-The-World) 做一些准备工作，比如 enable write barrier（写屏障）。然后取消 STW，将扫描任务作为多个并发的 goroutine 立即入队给调度器，进而被 CPU 处理；&lt;/li&gt;
&lt;li&gt;第一轮先扫描 root 对象，包括全局指针和 goroutine 栈上的指针，标记为灰色放入队列&lt;/li&gt;
&lt;li&gt;第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象；&lt;/li&gt;
&lt;li&gt;第三轮再次 STW，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了write barrier（写屏障）去记录&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Golang gc 优化的核心就是尽量使得 STW(Stop The World) 的时间越来越短。&lt;/p&gt;

&lt;p&gt;详细的Golang的GC介绍可以参看&lt;a href=&#34;https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/spec/02.0.md&#34;&gt;Golang垃圾回收&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;内存优化&#34;&gt;内存优化&lt;/h4&gt;

&lt;p&gt;通常小对象过多会导致 GC 三色法消耗过多的GPU。在编程过程中，尽可能减少对象分配，如使用结构体变量、减少值传递等。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>GO 1.13版本改进</title>
      <link>https://www.wingsxdu.com/p1391/</link>
      <pubDate>Mon, 09 Sep 2019 03:45:17 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1391/</guid>
      
        <description>

&lt;p&gt;Go1.13 版本在 Go1.12 发布六个月后推出。它的大部分变化都在工具链(toolchain)，运行时(runtime)和库的实现。&lt;span&gt;从  Go1.13 开始，在Go1.11开始酝酿的诸多决定终于开始逐个生效：首先是模块化将成为默认的特性，彻底告别&lt;/span&gt;&lt;code&gt;GOPATH&lt;/code&gt;&lt;span&gt;时代；其次是不是太重要的二进制特性将被废除；最后是语言的进化将再次启动，一些细微的语言特性将在Go2到来之前被提前实现。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在2018年官方已经发布了 Go2 的设计草案，其中包含了令人惊喜的范型和错误等诸多改进，在后 Go1 时代过去之后将是新兴的 Go2 时代。需要说明的是，Go2 的诞生并不表示 Go1 被抛弃！如何避免 Python3 的笑话正是 Go2 第一要考虑的问题，因此才会有 Go1.11 到 Go2 逐步过段的阶段。而 Go 语言官方也已经通过博文承诺 Go2 将保持对 Go1 软件资产的最大兼容，开发者采用增量更新的方式将 Go1 逐渐过渡到 Go2，&lt;/span&gt;这个进程主要由社区来负责驱动，只要不会带来向后不兼容的问题，每个 Go 2 的提议都有可能会在更早的版本发布出来。&lt;/p&gt;

&lt;p&gt;根据官方文档整理1.13版本变化。&lt;/p&gt;

&lt;h5 id=&#34;1-语法糖&#34;&gt;1.语法糖&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span&gt;二进制整数字面量：前缀 0b 或 0B 表示二进制整数字面量，例如 0b1011；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;八进制整数字面量：前缀 0o 或 0O 表示八进制整数字面量，例如 0o660（由前导 0 后跟八进制数字指示的八进制表示法仍然有效）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;十六进制浮点数字面量：现在可以使用前缀 0x 或 0X 来表示十六进制格式浮点数，例如 0x1.0p-1021。十六进制浮点数必须始终具有指数，写为字母 p 或 P，后跟十进制的指数。指数将尾数运算为2的指数幂。例 &lt;code&gt;0x1p-2&lt;/code&gt;&lt;span&gt;，代表十六进制的 1 除以 2²，也就是 0.25；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;虚部（复数常数的虚部）字面量：虚部&lt;span&gt;后缀 i 现在可以与任何（二进制，十进制，十六进制）整数或浮点字面值一起使用，例如：&lt;/span&gt;0xabci == 0xabc * 1i == 2748i 。&lt;/li&gt;
&lt;li&gt;数字分隔符：现在可以使用下划线分隔（分组）任何数字字面量，例如 1_000_000、0b_1010_0110、3.1415_9265，下划线可能出现在任何两位数字或字面量前缀和第一位数字之间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-工具&#34;&gt;2.工具&lt;/h5&gt;

&lt;h6 id=&#34;modules-改进&#34;&gt;Modules 改进&lt;/h6&gt;

&lt;p&gt;GO111MODULE 环境变量默认值仍为 auto，但只要当前工作目录包含或位于包含 go.mod 文件的目录下，auto 就会激活 go command 模块感知模式——即使当前目录在 GOPATH/src 内。&lt;/p&gt;

&lt;p&gt;此变更简化了 GOPATH/src 中现有代码的迁移，以及对模块感知软件包与非模块感知导入器的持续维护。&lt;/p&gt;

&lt;p&gt;GOPROXY 环境变量现在可以设置为以逗号分隔的代理 URL 列表或特殊的token值 direct，其默认值现为&lt;a href=&#34;https://proxy.golang.org,direct。解析包含其模块的包路径时，go命令将连续尝试列表中每个代理上的所有候选模块路径。除404、410之外，无法访问的代理或&#34;&gt;https://proxy.golang.org,direct。解析包含其模块的包路径时，go命令将连续尝试列表中每个代理上的所有候选模块路径。除404、410之外，无法访问的代理或&lt;/a&gt; HTTP 状态代码将使搜索终止，而无需咨询其余代理。&lt;/p&gt;

&lt;p&gt;GOPRIVATE(new) 环境变量用于声明不公开的模块路径。用作较低优先级的 GONOPROXY 和GONOSUMDB 变量的默认值，通过代理提取哪些模块并使用校验和数据库进行验证，从而提供更精细的操控。&lt;/p&gt;

&lt;p&gt;GOSUMDB(new) 环境变量可标识数据库的名称、可选的公钥和服务器 URL，以查询主模块的go.sum文件中尚未列出的模块的校验和。如果 GOSUMDB 不包含显式 URL，则通过检索支持校验和数据库的 GOPROXY URL来选择 URL，如果所有代理都不支持，则返回到指定数据库的直接连接。如果GOSUMDB设置为off，则不会查询校验和数据库，只验证 go.sum 文件中的现有校验和。&lt;/p&gt;

&lt;p&gt;若用户无法访问默认代理和校验和数据库（例如由于防火墙配置）可将 GOPROXY设置为 dircet和/或将 GOSUMDB 设置为 off 。&lt;/p&gt;

&lt;p&gt;go env -w 指令可用于设置这些变量的默认值，全平台通用：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;bash&#34;&gt;go env -w GOPROXY=direct
go env -w GOSUMDB=off&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>beego 是怎样的存在？</title>
      <link>https://www.wingsxdu.com/p1386/</link>
      <pubDate>Sun, 08 Sep 2019 15:59:52 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1386/</guid>
      
        <description>

&lt;p&gt;&lt;span&gt;beego 是一个 RESTFul 的 Go 应用框架，可以用来快速开发 API 、Web、后端服务等各种应用，主程是国人，开发历史悠久。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;beego 可以说是小白学习 golang 的“不二门选”，无论是原生中文文档，还是各大视频网站、技术社区上的教程。这样的环境下，如果我是一个初学者，我也会选择 beego，毕竟没人喜欢找罪受。然而 beego 自出世以来就饱受批斗，它真的有那么差劲吗？&lt;/p&gt;

&lt;h5 id=&#34;性能&#34;&gt;性能&lt;/h5&gt;

&lt;p&gt;&lt;span&gt;由于 golang 提供了完善的 net/http 标准库，基于该标准库实现一个 web 框架的难度相比其他语言低了不少，自己写一些 http 工具包也不是什么难事。在原生标准库和协程高并发的加持下，各个框架的的性能都十分出色，除非过度封装，这方面大家都拉不开差距 。&lt;/span&gt;&lt;/p&gt;

&lt;h5 id=&#34;应用&#34;&gt;应用&lt;/h5&gt;

&lt;p&gt;&lt;span&gt;无论是 beego 还是 gin、echo 都有自己的应用场景，以 go 语言的风格来说 beego 显得有些臃肿，但也不影响它依然是 go MVC 较好的解决方案，其用户不乏国内知名企业。&lt;/span&gt;&lt;/p&gt;

&lt;h5 id=&#34;工程结构&#34;&gt;工程结构&lt;/h5&gt;

&lt;p&gt;beego 的工程结构风格在 go 语言中显得有些格格不入。对 go 语言来说，各&lt;span&gt;类框架只是一个工具，都是通过 import 的方式（就像使用标准包），而 beego 少见的规定了项目结构——正常情况下，新建一个空文件夹就是一个 go 工程。对于很多 go 开发者，很不喜欢让别人来规定一个项目结构，过度封装导致很多特性被限制死了，缺失了灵活性，难免让人在开发中觉得蹩手蹩脚。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;除此之外，beego 号称由 8 大模块构成，开发者可根据需求自行引入（可见作者的野心）。然而即使在详细的原生中文文档加持下，一些模块仍然让开发者感觉很难用。而且随着需求的不断精进，业务开发也不会局限于 CURD 等基础操作，在社区也有更专精的替代品，也没必要自讨苦吃。&lt;/p&gt;

&lt;h5 id=&#34;学会适应一门语言&#34;&gt;学会适应一门语言&lt;/h5&gt;

&lt;p&gt;golang 是一门比较奇怪的语言，奇怪的语法，奇怪的语言特性、奇怪的语言风格。但有利也有弊，对于 go 开发者，哪怕你三个月不写 go ，再用起来也像昨天写过一样，看别人的代码也像是自己写的。适应之后可以快速上手。其实 beego 的野心可见一斑，大概是想做 go 语言中的 java Spring？beego 的风格可以说是最接近人们理解的框架概念，但这就在 go 中引起了许多人的批判——偏离的 go 独特的语言风格。它不是不够好，只是让开发者们觉得。。。用不上，有更变便利的工具，更好的解决方案，更舒适的编程方式。&lt;/p&gt;

&lt;p&gt;注：作者未使用过 beego 进行正经的项目开发。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>UTF-8 编码与 mysql中的 utf8、utf8mb4</title>
      <link>https://www.wingsxdu.com/p1373/</link>
      <pubDate>Mon, 19 Aug 2019 15:10:43 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1373/</guid>
      
        <description>

&lt;h5 id=&#34;utf-8编码&#34;&gt;UTF-8编码&lt;/h5&gt;

&lt;p&gt;&lt;span&gt;UTF-8 是一种&lt;strong&gt;&lt;span style=&#34;color: #ff0000;&#34;&gt;变长字节编码&lt;/span&gt;&lt;/strong&gt;方式。对于某一个字符的UTF-8编码，如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头。UTF-8 最多可用到6个字节。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如表：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1字节 0xxxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2字节 110xxxxx 10xxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3字节 1110xxxx 10xxxxxx 10xxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因此 UTF-8 中可以用来表示字符编码的实际位数最多有31位，即上表中 x 所表示的位。除去控制位（每字节开头的10等），这些 x 表示的位与 UNICODE 编码是一一对应的，位高低顺序也相同。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;将 UNICODE 转换为 UTF-8 编码时应先去除高位0，然后根据所剩编码的位数决定所需最小的 UTF-8 编码位数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;UNICODE 兼容 ASCII，只需要一个字节的 UTF-8 编码（7个二进制位）便可以表示。&lt;/span&gt;&lt;/p&gt;

&lt;h6 id=&#34;示例&#34;&gt;示例&lt;/h6&gt;

&lt;p&gt;以“9月”为例，展示如何实现 UTF-8 编码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UTF-8 编码：00111001—39—“9”&lt;/li&gt;
&lt;li&gt;UTF-8 编码：11100110 10011100 10001000—E6 9C 88—“月”&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;span-unicode-与-utf-8-转换-span&#34;&gt;&lt;span&gt;Unicode 与 UTF-8 转换&lt;/span&gt;&lt;/h6&gt;

&lt;p&gt;&lt;span&gt;Unicode 符号范围 | UTF-8 编码方式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;     (十六进制)      |    （二进制）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-+&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;0000 0000-0000 007F | 0xxxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;0000 0080-0000 07FF | 110xxxxx 10xxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;汉字“严”为例，已知“严”的 Unicode是 4E25（100 111000 100101），根据上表，4E25 处在第三行的范围内（07FF-FFFF），因此“严”的 UTF-8 编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。因此“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是 E4B8A5。&lt;/p&gt;

&lt;h5 id=&#34;mysql-中的-utf8&#34;&gt;Mysql 中的 utf8&lt;/h5&gt;

&lt;p&gt;&lt;span&gt;Mysql 从 4.1 版本开始支持 utf8 编码，而标准的 UTF-8 编码在其之后才正式发布。准确地说，utf8 的全名应该叫——utf8mb3（max byte 3），其编码的最大字符长度为 3 字节，而三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xFFFF，也就是 Unicode 中的基本多文平面（BMP）。也就是说，任何不在基本多文平面的 Unicode字符，都无法使用MySQL原有的 utf8 字符集存储。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;中文基本汉字+基本汉字补充的 Unicode 编码范围为：4E00-9FCB，共计收录 20940个汉字，而&lt;/span&gt;扩展 B 编码范围为 20000-2A6D6，扩展 C 为2A700-2B734，扩展 D为 2B740-2B81D，共计 47082 个汉字，以及其他的兼容扩展等。这些编码范围大于 FFFF 的不常用汉字、&lt;span&gt;我们常见的 Emoji 表情（Emoji 是一种特殊的 Unicode 编码）、任何新增的 Unicode 字符等等&lt;/span&gt;，在 Mysql 中并不会完整地存储下来，并导致了整个字段的乱码。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;于是在 5.5.3 版本中，Mysql 添加了对 utf8mb4 编码的支持，最大字符长度为四字节，也就是说 utf8mb4 才是我们传统意义上的 UTF-8。然而遗憾的是，在 Mysql 的众多分支版本中，只有 8.0.x 分支中默认开启的是 utfmb4，其他分支依然是 utf8 编码——尤其在 linux 系统的源仓库中。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&#34;title-article&#34; style=&#34;text-align: center;&#34;&gt;
  &lt;span style=&#34;color: #ff0000;&#34;&gt;&lt;strong&gt;永远不要在MySQL中使用 utf8，改用 utf8mb4。&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;

&lt;h5 id=&#34;mysql-简史&#34;&gt;MySQL 简史&lt;/h5&gt;

&lt;p&gt;为什么 MySQL 开发者会让“utf8”失效?我们或许可以从提交日志中寻找答案。&lt;/p&gt;

&lt;p&gt;MySQL 从4.1版本开始支持 UTF-8，也就是2003年，而今天使用的 UTF-8 标准(RFC 3629)是随后才出现的。&lt;/p&gt;

&lt;p&gt;旧版的 UTF-8 标准(RFC 2279)最多支持每个字符6个字节。2002年3月28日，MySQL开发者在第一个MySQL 4.1预览版中使用了RFC 2279。&lt;/p&gt;

&lt;p&gt;同年9月，他们对 MySQL 源代码进行了一次调整：“UTF8现在最多只支持3个字节的序列”。&lt;/p&gt;

&lt;p&gt;是谁提交了这些代码?他为什么要这样做?这个问题不得而知。在迁移到 Git 后(MySQL最开始使用的是BitKeeper)，MySQL 代码库中的很多提交者的名字都丢失了。2003年9月的邮件列表中也找不到可以解释这一变更的线索。&lt;/p&gt;

&lt;p&gt;不过我可以试着猜测一下。&lt;/p&gt;

&lt;p&gt;2002年，MySQL 做出了一个决定：如果用户可以保证数据表的每一行都使用相同的字节数，那么 MySQL 就可以在性能方面来一个大提升。为此，用户需要将文本列定义为“CHAR”，每个“CHAR”列总是拥有相同数量的字符。如果插入的字符少于定义的数量，MySQL 就会在后面填充空格，如果插入的字符超过了定义的数量，后面超出部分会被截断。&lt;/p&gt;

&lt;p&gt;MySQL 开发者在最开始尝试 UTF-8 时使用了每个字符6个字节，CHAR(1)使用6个字节，CHAR(2)使用12个字节，并以此类推。&lt;/p&gt;

&lt;p&gt;应该说，他们最初的行为才是正确的，可惜这一版本一直没有发布。但是文档上却这么写了，而且广为流传，所有了解 UTF-8 的人都认同文档里写的东西。&lt;/p&gt;

&lt;p&gt;不过很显然，MySQL 开发者或厂商担心会有用户做这两件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 CHAR 定义列(在现在看来，CHAR 已经是老古董了，但在那时，在 MySQL 中使用 CHAR 会更快，不过从2005年以后就不是这样子了)。&lt;/li&gt;
&lt;li&gt;将 CHAR 列的编码设置为“utf8”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我的猜测是 MySQL 开发者本来想帮助那些希望在空间和速度上双赢的用户，但他们搞砸了“utf8”编码。&lt;/p&gt;

&lt;p&gt;所以结果就是没有赢家。那些希望在空间和速度上双赢的用户，当他们在使用“utf8”的 CHAR 列时，实际上使用的空间比预期的更大，速度也比预期的慢。而想要正确性的用户，当他们使用“utf8”编码时，却无法保存像“”这样的字符。&lt;/p&gt;

&lt;p&gt;在这个不合法的字符集发布了之后，MySQL 就无法修复它，因为这样需要要求所有用户重新构建他们的数据库。最终，MySQL 在2010年重新发布了“utf8mb4”来支持真正的 UTF-8。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Golang strconv包使用</title>
      <link>https://www.wingsxdu.com/p1370/</link>
      <pubDate>Fri, 09 Aug 2019 09:45:19 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1370/</guid>
      
        <description>&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt; // atob.go
        ------------------------------------------------------------
        // ParseBool 将字符串转换为布尔值
        // 它接受真值：1, t, T, TRUE, true, True
        // 它接受假值：0, f, F, FALSE, false, False.
        // 其它任何值都返回一个错误
        func ParseBool(str string) (value bool, err error)
        func main() {
    fmt.Println(strconv.ParseBool(&#34;1&#34;))    // true 
    fmt.Println(strconv.ParseBool(&#34;t&#34;))    // true 
    fmt.Println(strconv.ParseBool(&#34;T&#34;))    // true 
    fmt.Println(strconv.ParseBool(&#34;true&#34;)) // true 
    fmt.Println(strconv.ParseBool(&#34;True&#34;)) // true 
    fmt.Println(strconv.ParseBool(&#34;TRUE&#34;)) // true 
    fmt.Println(strconv.ParseBool(&#34;TRue&#34;))  // false strconv.ParseBool: parsing &#34;TRue&#34;: invalid syntax
    fmt.Println(strconv.ParseBool(&#34;0&#34;))     // false 
    fmt.Println(strconv.ParseBool(&#34;f&#34;))     // false 
    fmt.Println(strconv.ParseBool(&#34;F&#34;))     // false 
    fmt.Println(strconv.ParseBool(&#34;false&#34;)) // false 
    fmt.Println(strconv.ParseBool(&#34;False&#34;)) // false 
    fmt.Println(strconv.ParseBool(&#34;FALSE&#34;)) // false 
    fmt.Println(strconv.ParseBool(&#34;FALse&#34;)) // false strconv.ParseBool: parsing &#34;FAlse&#34;: invalid syntax
    }

------------------------------------------------------------
// FormatBool 将布尔值转换为字符串 &#34;true&#34; 或 &#34;false&#34;
func FormatBool(b bool) string
func main() {
    fmt.Println(strconv.FormatBool(0 &amp;lt; 1)) // true
    fmt.Println(strconv.FormatBool(0 &amp;gt; 1)) // false
    }

------------------------------------------------------------
// AppendBool 将布尔值 b 转换为字符串 &#34;true&#34; 或 &#34;false&#34;
// 然后将结果追加到 dst 的尾部，返回追加后的 []bytefunc 
AppendBool(dst []byte, b bool) []byte
func main() {
    rst := make([]byte, 0)
    rst = strconv.AppendBool(rst, 0 &amp;lt; 1)
    fmt.Printf(&#34;%s\n&#34;, rst) // true
    rst = strconv.AppendBool(rst, 0 &amp;gt; 1)
    fmt.Printf(&#34;%s\n&#34;, rst) // truefalse
    }



============================================================
// atof.go
------------------------------------------------------------
// ParseFloat 将字符串转换为浮点数
// s：要转换的字符串
// bitSize：指定浮点类型（32:float32、64:float64）
// 如果 s 是合法的格式，而且接近一个浮点值，
// 则返回浮点数的四舍五入值（依据 IEEE754 的四舍五入标准）
// 如果 s 不是合法的格式，则返回“语法错误”
// 如果转换结果超出 bitSize 范围，则返回“超出范围”
func ParseFloat(s string, bitSize int) (f float64, err error)
func main() {
    s := &#34;0.12345678901234567890&#34;
    f, err := strconv.ParseFloat(s, 32)
    fmt.Println(f, err)                // 0.12345679104328156 
    fmt.Println(float32(f), err)       // 0.12345679 
    f, err = strconv.ParseFloat(s, 64)
    fmt.Println(f, err)                // 0.12345678901234568 
    }



============================================================
// atoi.go
------------------------------------------------------------
// ErrRange 表示值超出范围var ErrRange = errors.New(&#34;value out of range&#34;)
// ErrSyntax 表示语法不正确var ErrSyntax = errors.New(&#34;invalid syntax&#34;)
// NumError 记录转换失败
type NumError struct {
    Func string // 失败的函数名(ParseBool, ParseInt, ParseUint, ParseFloat)
    Num  string // 输入的值
    Err  error  // 失败的原因(ErrRange, ErrSyntax)
    }
    // int 或 uint 类型的长度(32 或 64)
    const IntSize = intSize 
        const intSize = 32 &amp;lt;&amp;lt; uint(^uint(0)&amp;gt;&amp;gt;63)
// 实现 Error 接口，输出错误信息
func (e *NumError) Error() string
------------------------------------------------------------
// ParseInt 将字符串转换为 int 类型
// s：要转换的字符串
// base：进位制（2 进制到 36 进制）
// bitSize：指定整数类型（0:int、8:int8、16:int16、32:int32、64:int64）
// 返回转换后的结果和转换时遇到的错误
// 如果 base 为 0，则根据字符串的前缀判断进位制（0x:16，0:8，其它:10）
func ParseInt(s string, base int, bitSize int) (i int64, err error)
func main() {
    fmt.Println(strconv.ParseInt(&#34;123&#34;, 10, 8)) // 123 
    fmt.Println(strconv.ParseInt(&#34;12345&#34;, 10, 8))   // 127 strconv.ParseInt: parsing &#34;12345&#34;: value out of range
    fmt.Println(strconv.ParseInt(&#34;2147483647&#34;, 10, 0))  // 2147483647 
    fmt.Println(strconv.ParseInt(&#34;0xFF&#34;, 16, 0))    // 0 strconv.ParseInt: parsing &#34;0xFF&#34;: invalid syntax
    fmt.Println(strconv.ParseInt(&#34;FF&#34;, 16, 0))  // 255 
    fmt.Println(strconv.ParseInt(&#34;0xFF&#34;, 0, 0)) // 255 
    }

------------------------------------------------------------
// ParseUint 功能同 ParseInt 一样，只不过返回 uint 类型整数
func ParseUint(s string, base int, bitSize int) (n uint64, err error)
func main() {
    fmt.Println(strconv.ParseUint(&#34;FF&#34;, 16, 8)) // 255 
    }

------------------------------------------------------------
// Atoi 相当于 ParseInt(s, 10, 0)
// 通常使用这个函数，而不使用 
ParseIntfunc Atoi(s string) (i int, err error)
func main() {
    fmt.Println(strconv.Atoi(&#34;2147483647&#34;)) // 2147483647 
    fmt.Println(strconv.Atoi(&#34;2147483648&#34;)) // 2147483647 strconv.ParseInt: parsing &#34;2147483648&#34;: value out of range
    }



============================================================
// ftoa.go
------------------------------------------------------------
// FormatFloat 将浮点数 f 转换为字符串值
// f：要转换的浮点数
// fmt：格式标记（b、e、E、f、g、G）
// prec：精度（数字部分的长度，不包括指数部分）
// bitSize：指定浮点类型（32:float32、64:float64）
//// 格式标记：
// &#39;b&#39; (-ddddp±ddd，二进制指数)
// &#39;e&#39; (-d.dddde±dd，十进制指数)
// &#39;E&#39; (-d.ddddE±dd，十进制指数)
// &#39;f&#39; (-ddd.dddd，没有指数)
// &#39;g&#39; (&#39;e&#39;:大指数，&#39;f&#39;:其它情况)
// &#39;G&#39; (&#39;E&#39;:大指数，&#39;f&#39;:其它情况)
//// 如果格式标记为 &#39;e&#39;，&#39;E&#39;和&#39;f&#39;，则 prec 表示小数点后的数字位数
// 如果格式标记为 &#39;g&#39;，&#39;G&#39;，则 prec 表示总的数字位数（整数部分+小数部分）
func FormatFloat(f float64, fmt byte, prec, bitSize int) string
func main() {
    f := 100.12345678901234567890123456789
    fmt.Println(strconv.FormatFloat(f, &#39;b&#39;, 5, 32)) // 13123382p-17
    fmt.Println(strconv.FormatFloat(f, &#39;e&#39;, 5, 32)) // 1.00123e+02
    fmt.Println(strconv.FormatFloat(f, &#39;E&#39;, 5, 32)) // 1.00123E+02
    fmt.Println(strconv.FormatFloat(f, &#39;f&#39;, 5, 32)) // 100.12346
    fmt.Println(strconv.FormatFloat(f, &#39;g&#39;, 5, 32)) // 100.12
    fmt.Println(strconv.FormatFloat(f, &#39;G&#39;, 5, 32)) // 100.12
    fmt.Println(strconv.FormatFloat(f, &#39;b&#39;, 30, 32))    // 13123382p-17
    fmt.Println(strconv.FormatFloat(f, &#39;e&#39;, 30, 32))    // 1.001234588623046875000000000000e+02
    fmt.Println(strconv.FormatFloat(f, &#39;E&#39;, 30, 32))    // 1.001234588623046875000000000000E+02
    fmt.Println(strconv.FormatFloat(f, &#39;f&#39;, 30, 32))    // 100.123458862304687500000000000000
    fmt.Println(strconv.FormatFloat(f, &#39;g&#39;, 30, 32))    // 100.1234588623046875
    fmt.Println(strconv.FormatFloat(f, &#39;G&#39;, 30, 32))    // 100.1234588623046875
    }

------------------------------------------------------------
// AppendFloat 将浮点数 f 转换为字符串值，并将转换结果追加到 dst 的尾部
// 返回追加后的 []bytefunc 
AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) []byte
func main() {
    f := 100.12345678901234567890123456789
    b := make([]byte, 0)
    b = strconv.AppendFloat(b, f, &#39;f&#39;, 5, 32)
    b = append(b, &#34;   &#34;...)
    b = strconv.AppendFloat(b, f, &#39;e&#39;, 5, 32)
    fmt.Printf(&#34;%s&#34;, b) // 100.12346   1.00123e+0
    }


============================================================
// itoa.go
------------------------------------------------------------
// FormatUint 将 int 型整数 i 转换为字符串形式
// base：进位制（2 进制到 36 进制）
// 大于 10 进制的数，返回值使用小写字母 &#39;a&#39; 到 &#39;z&#39;func 
FormatInt(i int64, base int) string
func main() {
    i := int64(-2048)
    fmt.Println(strconv.FormatInt(i, 2))  // -100000000000
    fmt.Println(strconv.FormatInt(i, 8))  // -4000
    fmt.Println(strconv.FormatInt(i, 10)) // -2048
    fmt.Println(strconv.FormatInt(i, 16)) // -800
    fmt.Println(strconv.FormatInt(i, 36)) // -1kw
    }

------------------------------------------------------------
// FormatUint 将 uint 型整数 i 转换为字符串形式
// base：进位制（2 进制到 36 进制）
// 大于 10 进制的数，返回值使用小写字母 &#39;a&#39; 到 &#39;z&#39;func 
FormatUint(i uint64, base int) string
func main() {
    i := uint64(2048)
    fmt.Println(strconv.FormatUint(i, 2))  // 100000000000
    fmt.Println(strconv.FormatUint(i, 8))  // 4000
    fmt.Println(strconv.FormatUint(i, 10)) // 2048
    fmt.Println(strconv.FormatUint(i, 16)) // 800
    fmt.Println(strconv.FormatUint(i, 36)) // 1kw
    }

------------------------------------------------------------
// Itoa 相当于 FormatInt(i, 10)func Itoa(i int) string
func main() {
    fmt.Println(strconv.Itoa(-2048)) // -2048
    fmt.Println(strconv.Itoa(2048))  // 2048
    }

------------------------------------------------------------
// AppendInt 将 int 型整数 i 转换为字符串形式，并追加到 dst 的尾部
// i：要转换的字符串
// base：进位制
// 返回追加后的 []bytefunc 
AppendInt(dst []byte, i int64, base int) []byte
func main() {
    b := make([]byte, 0)
    b = strconv.AppendInt(b, -2048, 16)
    fmt.Printf(&#34;%s&#34;, b) // -800
    }

------------------------------------------------------------
// AppendUint 将 uint 型整数 i 转换为字符串形式，并追加到 dst 的尾部
// i：要转换的字符串
// base：进位制
// 返回追加后的 []bytefunc 
AppendUint(dst []byte, i uint64, base int) []byte
func main() {
    b := make([]byte, 0)
    b = strconv.AppendUint(b, 2048, 16)
    fmt.Printf(&#34;%s&#34;, b) // 800
    }



============================================================
// quote.go
------------------------------------------------------------
// Quote 将字符串 s 转换为“双引号”引起来的字符串
// 其中的特殊字符将被转换为“转义字符”
// “不可显示的字符”将被转换为“转义字符”
func Quote(s string) string
func main() {
    fmt.Println(strconv.Quote(`C:\Windows`))    // &#34;C:\\Windows&#34;
    }

------------------------------------------------------------
// AppendQuote 将字符串 s 转换为“双引号”引起来的字符串，
// 并将结果追加到 dst 的尾部，返回追加后的 []byte
// 其中的特殊字符将被转换为“转义字符”func 
AppendQuote(dst []byte, s string) []byte
func main() {
    s := `C:\Windows`
    b := make([]byte, 0)
    b = strconv.AppendQuote(b, s)
    fmt.Printf(&#34;%s&#34;, b) // &#34;C:\\Windows&#34;
    }

------------------------------------------------------------
// QuoteToASCII 将字符串 s 转换为“双引号”引起来的 ASCII 字符串
// “非 ASCII 字符”和“特殊字符”将被转换为“转义字符”
func QuoteToASCII(s string) string
func main() {
    fmt.Println(strconv.QuoteToASCII(&#34;Hello 世界！&#34;))  // &#34;Hello \u4e16\u754c\uff01&#34;
    }

------------------------------------------------------------
// AppendQuoteToASCII 将字符串 s 转换为“双引号”引起来的 ASCII 字符串，
// 并将结果追加到 dst 的尾部，返回追加后的 []byte
// “非 ASCII 字符”和“特殊字符”将被转换为“转义字符”
func AppendQuoteToASCII(dst []byte, s string) []byte
func main() {
    s := &#34;Hello 世界！&#34;
    b := make([]byte, 0)
    b = strconv.AppendQuoteToASCII(b, s)
    fmt.Printf(&#34;%s&#34;, b) // &#34;Hello \u4e16\u754c\uff01&#34;
    }

------------------------------------------------------------
// QuoteRune 将 Unicode 字符转换为“单引号”引起来的字符串
// “特殊字符”将被转换为“转义字符”
func QuoteRune(r rune) string
func main() {
    fmt.Println(strconv.QuoteRune(&#39;好&#39;)) // &#39;好&#39;
    }

------------------------------------------------------------
// AppendQuoteRune 将 Unicode 字符转换为“单引号”引起来的字符串，
// 并将结果追加到 dst 的尾部，返回追加后的 []byte
// “特殊字符”将被转换为“转义字符”
func AppendQuoteRune(dst []byte, r rune) []byte
func main() {
    b := make([]byte, 0)
    b = strconv.AppendQuoteRune(b, &#39;好&#39;)
    fmt.Printf(&#34;%s&#34;, b) // &#39;好&#39;
    }

------------------------------------------------------------
// QuoteRuneToASCII 将 Unicode 字符转换为“单引号”引起来的 ASCII 字符串
// “非 ASCII 字符”和“特殊字符”将被转换为“转义字符”
func QuoteRuneToASCII(r rune) string
func main() {
    fmt.Println(strconv.QuoteRuneToASCII(&#39;好&#39;))  // &#39;\u597d&#39;
    }

------------------------------------------------------------
// AppendQuoteRune 将 Unicode 字符转换为“单引号”引起来的 ASCII 字符串，
// 并将结果追加到 dst 的尾部，返回追加后的 []byte
// “非 ASCII 字符”和“特殊字符”将被转换为“转义字符”
func AppendQuoteRuneToASCII(dst []byte, r rune) []byte
func main() {
    b := make([]byte, 0)
    b = strconv.AppendQuoteRuneToASCII(b, &#39;好&#39;)
    fmt.Printf(&#34;%s&#34;, b) // &#39;\u597d&#39;
    }

------------------------------------------------------------
// CanBackquote 判断字符串 s 是否可以表示为一个单行的“反引号”字符串
// 字符串中不能含有控制字符（除了 \t）和“反引号”字符，否则返回 false
func CanBackquote(s string) bool
func main() {
    b := strconv.CanBackquote(&#34;C:\\Windows\n&#34;)
    fmt.Println(b) // false
    b = strconv.CanBackquote(&#34;C:\\Windows\r&#34;)
    fmt.Println(b) // false
    b = strconv.CanBackquote(&#34;C:\\Windows\f&#34;)
    fmt.Println(b) // false
    b = strconv.CanBackquote(&#34;C:\\Windows\t&#34;)
    fmt.Println(b) // true
    b = strconv.CanBackquote(&#34;C:\\`Windows`&#34;)
    fmt.Println(b) // false
    }

------------------------------------------------------------
// UnquoteChar 将 s 中的第一个字符“取消转义”并解码
//// s：转义后的字符串
// quote：字符串使用的“引号符”（用于对引号符“取消转义”）
//// value：    解码后的字符
// multibyte：value 是否为多字节字符
// tail：     字符串 s 除去 value 后的剩余部分
// error：    返回 s 中是否存在语法错误
//// 参数 quote 为“引号符”
// 如果设置为单引号，则 s 中允许出现 \&#39; 字符，不允许出现单独的 &#39; 字符
// 如果设置为双引号，则 s 中允许出现 \&#34; 字符，不允许出现单独的 &#34; 字符
// 如果设置为 0，则不允许出现 \&#39; 或 \&#34; 字符，可以出现单独的 &#39; 或 &#34; 字符
func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)
func main() {
    s := `\&#34;大\\家\\好！\&#34;`
    c, mb, sr, _ := strconv.UnquoteChar(s, &#39;&#34;&#39;)
    fmt.Printf(&#34;%-3c  %v\n&#34;, c, mb) for ; len(sr) &amp;gt; 0; c, mb, sr, _ = strconv.UnquoteChar(sr, &#39;&#34;&#39;) {
        fmt.Printf(&#34;%-3c  %v\n&#34;, c, mb)
    }   // &#34;    false
    // 大  true
    // \    false
    // 家  true
    // \    false
    // 好  true
    // ！  true
    }

------------------------------------------------------------
// Unquote 将“带引号的字符串” s 转换为常规的字符串（不带引号和转义字符）
// s 可以是“单引号”、“双引号”或“反引号”引起来的字符串（包括引号本身）
// 如果 s 是单引号引起来的字符串，则返回该该字符串代表的字符
func Unquote(s string) (t string, err error)
func main() {
    sr, err := strconv.Unquote(`&#34;\&#34;大\t家\t好！\&#34;&#34;`)
    fmt.Println(sr, err)
    sr, err = strconv.Unquote(`&#39;大家好！&#39;`)
    fmt.Println(sr, err)
    sr, err = strconv.Unquote(`&#39;好&#39;`)
    fmt.Println(sr, err)
    sr, err = strconv.Unquote(&#34;`大\\t家\\t好！`&#34;)
    fmt.Println(sr, err)
}

------------------------------------------------------------
// IsPrint 判断 Unicode 字符 r 是否是一个可显示的字符
// 可否显示并不是你想象的那样，比如空格可以显示，而\t则不能显示
// 具体可以参考 Go 语言的源码
func IsPrint(r rune) bool
func main() {
    fmt.Println(strconv.IsPrint(&#39;a&#39;))   // true
    fmt.Println(strconv.IsPrint(&#39;好&#39;))  // true
    fmt.Println(strconv.IsPrint(&#39; &#39;))   // true
    fmt.Println(strconv.IsPrint(&#39;\t&#39;))  // false
    fmt.Println(strconv.IsPrint(&#39;\n&#39;))  // false
    fmt.Println(strconv.IsPrint(0))     // false
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Go 变量覆盖问题</title>
      <link>https://www.wingsxdu.com/p1368/</link>
      <pubDate>Fri, 09 Aug 2019 03:12:54 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1368/</guid>
      
        <description>&lt;p&gt;如下代码&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;package main

func main() {
    x := 1
    println(x)      // 1
    {
        println(x)  // 1
        x := 2
        println(x)  // 2    // 新的 x 变量的作用域只在代码块内部
    }
    println(x)      // 1
}&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;span&gt;代码引用变量时总会最优先查找当前代码块中（不包含任何子代码块）的那个变量；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，一层一层的查找；&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>因为我们有梦想</title>
      <link>https://www.wingsxdu.com/p1366/</link>
      <pubDate>Fri, 09 Aug 2019 02:08:22 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1366/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;越认真的人，越容易陷入迷茫。&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;生命的意义是什么？&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;努力的意义在哪里？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;答案有千百种。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2018年，1523万中国新生儿开启了他们的生命旅程，993万人辞别人间。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;975万高三学生提枪上马奔赴高考。&lt;/span&gt;&lt;span&gt;34万人超过600分，不负一场修行。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3000万环卫工人，在每天凌晨4:15的时候，准时出现在全国700个城市街头。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;360万美团商家、270万外卖小哥一起送出63.9亿份外卖。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;饿了么骑手刘务桂跑了63221公里，相当于绕行赤道1.5圈。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;300万快递员骑着电驴，送出500亿件快递。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;平均每个快递员每月送货距离接近2000km，相当于从北京骑行到广州。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1386万农村贫困人口，劳动脱贫。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;彼时，中国A股上市公司，近五千高管年薪过百万，也是这一年，A股每天至少有一位董事长失业。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;820万大学生告别母校。&lt;/span&gt;&lt;span&gt;80%的毕业生挣到第一笔薪水。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;全世界，从未有这么庞大的一群人，对未来充满着乐观美好的想象，如此勤奋，如此吃苦，如此拼搏。&lt;/span&gt;&lt;span&gt;因为每一个你们，中国还在前进。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;努力的意义，生命的意义，从来没有标准答案。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;谁不曾受过生活的优待，谁又不曾经受过生活的刁难，谁又不曾念过那本难念的经。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;14亿种悲喜交加，14亿种负重前行。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好好&lt;/span&gt;&lt;span&gt;活着，就是胜利。&lt;/span&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Go ECHO JWT 变量类型</title>
      <link>https://www.wingsxdu.com/p1364/</link>
      <pubDate>Tue, 06 Aug 2019 10:09:33 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1364/</guid>
      
        <description>&lt;p&gt;最近在写自己的开源案例时，需要在 token 里面存入用户的 uid，变量类型为 uint64,然而解析token 中的值时却报错变量不符，类型为 float。示例：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;claims[&#34;uid&#34;] = uid //编码
uid := claims[&#34;uid&#34;].(uint64) //解码&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但如果编码与解码统一用 string 类型即可正常取值&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;claims[&#34;uid&#34;] = strconv.FormatUint(uid, 10) //编码 
uid := claims[&#34;uid&#34;].(string) //解码&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于文档里没有介绍具体原因，只能类型转换存进去了&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Go 全局变量作用域</title>
      <link>https://www.wingsxdu.com/p1357/</link>
      <pubDate>Tue, 23 Jul 2019 10:55:16 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1357/</guid>
      
        <description>

&lt;h5 id=&#34;问题所在&#34;&gt;问题所在&lt;/h5&gt;

&lt;p&gt;&lt;span&gt;全局变量的作用域是整个包，局部变量的作用域是该变量所在的花括号内。最近使用 gorm 时遇到了使用全局变量赋值作用域的问题。&lt;/span&gt;&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;var db *gorm.DB // 全局变量用 =

func Init() {
    db, err := gorm.Open(&#34;mysql&#34;, &#34;//&#34;)
    debug.CheckErr(err)
    //defer db.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用语法糖 := 赋值，全局变量 db 的作用域只在 Init{} 函数内，其他函数内调用会报错空指针。&lt;/p&gt;

&lt;p&gt;因此若避免全局变量变成局部变量，应采用 “=&amp;#8221; 写法：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;var db *gorm.DB // 全局变量用 =

func Init() {
    var err error
    db, err = gorm.Open(&#34;mysql&#34;, &#34;//&#34;)
    debug.CheckErr(err)
    //defer db.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;此时 db 可在包内的其他函数中调用&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Go mod 模块化管理</title>
      <link>https://www.wingsxdu.com/p1351/</link>
      <pubDate>Tue, 23 Jul 2019 08:21:35 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1351/</guid>
      
        <description>

&lt;h5 id=&#34;前言&#34;&gt;前言&lt;/h5&gt;

&lt;p&gt;&lt;span&gt;在Go语言的发展史中，2018年注定是一个重要的时间点，因为在8月正式发布了Go1.11。Go1.11语言部分虽然没有变化，但是带来了3个重量级的更新：一是&lt;/span&gt;&lt;code&gt;amd64&lt;/code&gt;&lt;span&gt;平台完全支持&lt;/span&gt;&lt;code&gt;AVX512&lt;/code&gt;&lt;span&gt;高性能的指令集；二是Go1.11开始支持模块化的特性；三是Go语言开始WebAssembly平台。这几个改进将成为后Go1时代最大的亮点。而模块是管理任何大型工程必备的工具，但是Go语言发布十年来一直缺乏官方的模块化工具。模块化的特性将彻底解决大型Go语言工程的管理问题，至此Go1除了缺少泛型等特性已经近乎完美。从Go1.13开始（2019年8月），模块化将成为默认的特性，彻底告别&lt;code&gt;GOPATH&lt;/code&gt;时代；&lt;/span&gt;&lt;/p&gt;

&lt;h5 id=&#34;使用&#34;&gt;使用&lt;/h5&gt;

&lt;p&gt;golang 1.11版本开启服务：&lt;code class=&#34;null&#34;&gt;set GO111MODULE=on&lt;/code&gt;，高于此版本不用开启&lt;/p&gt;

&lt;p&gt;存在网络环境问题的可以设置代理：&lt;code class=&#34;null&#34;&gt;export GOPROXY=&lt;a href=&#34;https://goproxy.io&#34;&gt;https://goproxy.io&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;取消代理（设置地址为空）：&lt;code class=&#34;null&#34;&gt;export GOPROXY=&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用go mod 管理项目，就不需要非得把项目放到GOPATH指定目录下，你可以在任何目录下新建一个项目：&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code class=&#34;null&#34;&gt;cd Desktop/test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&#34;null&#34;&gt;go mod init&lt;/code&gt; // 初始化模块，会在项目根目录下生成 &lt;code class=&#34;null&#34;&gt;go.mod&lt;/code&gt;文件。&lt;/li&gt;
&lt;li&gt;&lt;code class=&#34;null&#34;&gt;go mod tidy&lt;/code&gt; // 根据&lt;code class=&#34;null&#34;&gt;go.mod&lt;/code&gt;文件来处理依赖关系，生成&lt;code class=&#34;null&#34;&gt;go.sum&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod vendor&lt;/code&gt; // &lt;span&gt;将依赖包复制到项目下的 &lt;/span&gt;&lt;code&gt;vendor&lt;/code&gt;&lt;span&gt;目录。&lt;span style=&#34;color: #ff0000;&#34;&gt;强烈不推荐使用&lt;/span&gt;，建议使用被墙包实在无法下载的可以这么处理，方便用户快速使用命令&lt;/span&gt;&lt;code&gt;go build -mod=vendor&lt;/code&gt;&lt;span&gt;编译&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;span&gt;go.mod 文件必须要提交到git仓库，但 go.sum 文件可以不用提交到git仓库，go.sum 文件为包签名，跨平台条件下可能会报错；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;go 模块版本控制的下载文件及信息会存储到 GOPATH/pkg/mod 文件夹里，src 目录下不再存放包；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;环境变量GOPATH不再用于解析imports包路径，即原有的GOPATH/src/下的包，通过import是找不到了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;旧版 go get 取包过程类似：git clone + go install , 开启Go Module功能后 go get 只有 git clone(download)过程了。老的go get取完主包后，会对其repo下的submodule进行循环拉取。新的go get不再支持submodule子模块拉取。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;版本问题&#34;&gt;版本问题&lt;/h5&gt;

&lt;p&gt;在执行编译指令 go build/run 或 go mod tidy 后会根据 import 的包自动索引，但是部分包的 import 路径已经改变，如：echo 的 &lt;code class=&#34;null&#34;&gt;import &lt;/code&gt;&lt;code class=&#34;null&#34;&gt;&amp;ldquo;github.com/labstack/echo/&amp;rdquo;&lt;/code&gt;索引的包最高为 v3 版本，&lt;code class=&#34;null&#34;&gt;import &lt;/code&gt;&lt;code class=&#34;null&#34;&gt;&amp;ldquo;github.com/labstack/echo/v4&amp;rdquo;&lt;/code&gt;为echo 的v4版本。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux Mysql 数据库相关操作</title>
      <link>https://www.wingsxdu.com/p1258/</link>
      <pubDate>Thu, 30 May 2019 12:27:40 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1258/</guid>
      
        <description>&lt;p&gt;登录并创建数据库：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;mysql -u username-p
&amp;lt;span&gt;create database databasename;&amp;lt;/span&gt;
use databasename;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改表字段属性&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;alter table user MODIFY uid VARCHAR(10);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看表结构&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;desc user;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/mysql-desc-1-1.png&#34; alt=&#34;&#34; width=&#34;597&#34; height=&#34;315&#34; class=&#34;alignnone size-full wp-image-1259&#34; /&gt;&lt;/p&gt;

&lt;p&gt;查看建表语句&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;show create table user;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/mysql-show-1-1.png&#34; alt=&#34;&#34; width=&#34;1036&#34; height=&#34;455&#34; class=&#34;alignnone size-full wp-image-1260&#34; /&gt;&lt;/p&gt;

&lt;p&gt;退出Mysql&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;quit;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出整个数据库&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;mysqldump -u 用户名 -p 数据库名 &amp;gt; 导出的文件名
mysqldump -u root -p test &amp;gt; test.sql
ls//导出到当前目录下&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出某个表&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;mysqldump -u 用户名 -p 数据库名 表名&amp;gt; 导出的文件名
mysqldump -u root -p test user &amp;gt; test_user.sql
ls&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入数据库&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;mysql -u 用户名 -p 密码 数据库名 &amp;lt; 数据库名.sql
mysql -u root -p test &amp;lt; test.sql&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Ubunutu ECS服务器安装界面图形</title>
      <link>https://www.wingsxdu.com/p1256/</link>
      <pubDate>Wed, 29 May 2019 03:52:24 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1256/</guid>
      
        <description>&lt;nav&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#安装流程&#34;&gt;安装流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;

&lt;p&gt;linux 服务器都是没有界面图形的——当然也不需要界面图形，会消耗多余的资源。但是为了方便演示和开发调试，也会有界面图形的开发需求。&lt;/p&gt;

&lt;h6 id=&#34;安装流程&#34;&gt;安装流程&lt;/h6&gt;

&lt;p&gt;连接服务器：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;apt-get update
apt-get upgrade
# 安装ubuntu桌面系统，一路默认
apt-get install ubuntu-desktop
# 重启服务器
reb0ot&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登录：&lt;/p&gt;

&lt;p&gt;这时发现只能用 guest 用户登录，需要更改登录用户&lt;/p&gt;

&lt;p&gt;用 xshell 或putty 以 root 用户登录服务器（我直接用 winscp 修改文件）&lt;/p&gt;

&lt;p&gt;编辑：&lt;code class=&#34;null&#34;&gt;/usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;# 修改前
[Seat:*]
user-session=ubuntu
# 修改后
[Seat:*]
user-session=ubuntu
greeter-show-manual-login=true
allow-guest=false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑：&lt;code class=&#34;null&#34;&gt;/root/.profile&lt;/code&gt;&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;# 修改前
    # ~/.profile: executed by Bourne-compatible login shells.
    if [ &#34;$BASH&#34; ]; then
      if [ -f ~/.bashrc ]; then
        . ~/.bashrc
      fi
    fi
    mesg n || true
# 修改后
    # ~/.profile: executed by Bourne-compatible login shells.
    if [ &#34;$BASH&#34; ]; then
      if [ -f ~/.bashrc ]; then
        . ~/.bashrc
      fi
    fi
    tty -s &amp;&amp; mesg n || true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启服务器：reboot&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Ubuntu FISCO BCOS Web3 应用开发环境搭建</title>
      <link>https://www.wingsxdu.com/p1250/</link>
      <pubDate>Wed, 29 May 2019 03:08:31 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1250/</guid>
      
        <description>

&lt;p&gt;Java 应用的开发环境太繁琐了， 记一下搭建流程。（简化版）&lt;/p&gt;

&lt;h5 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h5&gt;

&lt;h6 id=&#34;安装jdk&#34;&gt;安装JDK&lt;/h6&gt;

&lt;p&gt;FISCO BCOS 要求 JDK 为Oracle 版本，下载链接：&lt;a href=&#34;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;a href=&#34;https://www.oracle.com/&#34;&gt;https://www.oracle.com/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装：&lt;code class=&#34;null&#34;&gt;sudo tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/local&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;配置环境变量：vi /etc/profile&lt;/p&gt;

&lt;p&gt;添加以下代码：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;export JAVA_HOME=/usr/local/jdk1.8.0_211
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重加载配置文件：&lt;code class=&#34;null&#34;&gt;source /etc/profile&lt;/code&gt;&lt;/p&gt;

&lt;h6 id=&#34;安装-gradle&#34;&gt;安装 Gradle&lt;/h6&gt;

&lt;p&gt;下载链接：&lt;a href=&#34;https://gradle.org/releases/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;a href=&#34;https://gradle.org/releases/&#34;&gt;https://gradle.org/releases/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装：&lt;code class=&#34;null&#34;&gt;sudo unzip -d /opt gradle.zip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;配置环境变量：vi /etc/profile&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;export GRADLE_HOME=/opt/gradle-5.4.1
export PATH=$GRADLE_HOME/bin:$PATH&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重加载配置文件：&lt;code class=&#34;null&#34;&gt;source /etc/profile&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;应用开发&#34;&gt;应用开发&lt;/h5&gt;

&lt;p&gt;IDE：idea&lt;/p&gt;

&lt;h6 id=&#34;获取-web3-应用开发包-cd-到工程目录下-执行-code-class-null-gradle-build-code&#34;&gt;获取 web3 应用开发包，cd 到工程目录下。执行&lt;code class=&#34;null&#34;&gt;gradle build&lt;/code&gt;。&lt;/h6&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Go Java 跨语言通信</title>
      <link>https://www.wingsxdu.com/p1244/</link>
      <pubDate>Mon, 27 May 2019 06:53:09 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1244/</guid>
      
        <description>

&lt;h5 id=&#34;前言&#34;&gt;前言&lt;/h5&gt;

&lt;p&gt;这两篇文章&lt;a href=&#34;https://www.wingsxdu.com/?p=1204&#34;&gt;Java Grpc 工程中使用&lt;/a&gt;  &lt;a href=&#34;https://www.wingsxdu.com/?p=1204&#34;&gt;Go GRPC使用&lt;/a&gt;  介绍了 golang、java 中 grpc 的使用，但仅仅是同语言的进程间通信，grpc 在性能上并没有优势。grpc 的优势在于跨语言。&lt;/p&gt;

&lt;h5 id=&#34;服务端与客户端&#34;&gt;服务端与客户端&lt;/h5&gt;

&lt;p&gt;这里的服务端指接受数据并将处理后的结果发送回去，客户端指发送数据至另一个程序进行处理。简言之，一个是发送消息，一个是接受消息并处理，与传统的前后端交互没有区别。grpc 使得跨语言程序间的通信服务开发更加便捷。&lt;/p&gt;

&lt;p&gt;在微服务中，一个程序可以是服务端也可以是客户端，其身份取决于处理的任务类型。&lt;/p&gt;

&lt;h5 id=&#34;使用&#34;&gt;使用&lt;/h5&gt;

&lt;h6 id=&#34;开启服务&#34;&gt;开启服务&lt;/h6&gt;

&lt;p&gt;Java 程序与 Golang 程序先启动服务端，监听端口，再启动客户端发送信息。&lt;/p&gt;

&lt;h6 id=&#34;监听多项服务&#34;&gt;监听多项服务&lt;/h6&gt;

&lt;p&gt;多数情况下，程序间的通信不会只有一种类型的服务，添加多项任务监听：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;        server = ServerBuilder.forPort(port)
                .addService(new UserServer.CreateAccountImpl())
                .addService(new UserServer.AddItemImpl())
                .addService(new UserServer.DeleteItemImpl())
                .addService(new UserServer.HasItemImpl())
                .addService(new UserServer.StoreTransactionImpl())
                .addService(new UserServer.HasTransactionImpl())
                .addService(new UserServer.RefundImpl())
                .addService(new UserServer.GetTxByTxIdImpl())
                .build()
                .start();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java Grpc 工程中使用</title>
      <link>https://www.wingsxdu.com/p1227/</link>
      <pubDate>Thu, 23 May 2019 07:06:40 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1227/</guid>
      
        <description>

&lt;h5 id=&#34;续上篇介绍&#34;&gt;续上篇介绍&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://www.wingsxdu.com/?p=1216&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Java GRPC proto 编译&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在我们拿到了编译的 Java 文件，其中 User.java 为 rpc 通信，文件名同 .proto 文件名称；CreateAccountGrpc.java 为定义的服务名称，定义几个服务就会编译出几个**Grpc.java 文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/java-proto-1-name-1-1.png&#34; alt=&#34;&#34; width=&#34;646&#34; height=&#34;340&#34; class=&#34;size-full wp-image-1228 aligncenter&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;工程中使用&#34;&gt;工程中使用&lt;/h5&gt;

&lt;p&gt;在 src 目录下新建 package grpc.user，将proto 编译得到的 java类文件都复制到目录下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/java-proto-1-use-1-1.png&#34; alt=&#34;&#34; width=&#34;457&#34; height=&#34;437&#34; class=&#34;size-full wp-image-1229 aligncenter&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;build-gradle环境配置&#34;&gt;build.gradle环境配置&lt;/h6&gt;

&lt;p&gt;和 proto 编译配置保持一致即可&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;apply plugin: &#39;java&#39;
apply plugin: &#39;com.google.protobuf&#39;
apply plugin: &#39;idea&#39;
repositories {
    maven { url &#34;https://maven.aliyun.com/repository/central/&#34; }
}
dependencies {
    compile &#34;io.grpc:grpc-netty:1.20.0&#34;
    compile &#34;io.grpc:grpc-protobuf:1.20.0&#34;
    compile &#34;io.grpc:grpc-stub:1.20.0&#34;
}
buildscript {
    repositories {
        maven { url &#34;https://maven.aliyun.com/repository/central/&#34; }
    }
    dependencies {
        classpath &#39;com.google.protobuf:protobuf-gradle-plugin:0.8.8&#39;
    }
}
protobuf {
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.7.1&#39;
    }
    plugins {
        grpc {
            artifact = &#39;io.grpc:protoc-gen-grpc-java:1.20.0&#39;
        }
    }
    generateProtoTasks {
        ofSourceSet(&#39;main&#39;)*.plugins {
            grpc { }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;客户端&#34;&gt;客户端&lt;/h6&gt;

&lt;p&gt;在目录下新建 UserClient.java&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;java&#34;&gt;package grpc.user;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import java.util.concurrent.TimeUnit;
public class UserClient {
    private final ManagedChannel channel;
    private final CreateAccountGrpc.CreateAccountBlockingStub blockingStub;
    private final CreateAccountGrpc.CreateAccountStub Stub;
    public static void main(String[] args) {
        try {
            UserClient service = new UserClient(&#34;localhost&#34;, 1330);
            System.out.println(service.creatAccount(&#34;beihai&#34;));
            service.shutdown();
        } catch (Exception e) {
            System.out.println(&#34;出现错误：&#34;+e);
        }
    }
    public UserClient(String host, int port) {
        this(ManagedChannelBuilder.forAddress(host, port).usePlaintext());
    }
    /** Construct client for accessing RouteGuide server using the existing channel. */
    public UserClient(ManagedChannelBuilder&amp;lt;?&amp;gt; channelBuilder) {
        channel = channelBuilder.build();
        blockingStub = CreateAccountGrpc.newBlockingStub(channel);
        Stub = CreateAccountGrpc.newStub(channel);
    }
    public void shutdown() throws InterruptedException{
        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
    }
    public String creatAccount(String uid){
        User.CreateAccountRequest request = User.CreateAccountRequest.newBuilder().setUid(uid).setService(&#34;Register&#34;).build();
        User.CreateRequestResponse response = blockingStub.createAccount(request);
        return response.getValue();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;服务端&#34;&gt;服务端&lt;/h6&gt;

&lt;p&gt;在目录下新建 UserServer.java&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;package grpc.user;
import io.grpc.Server;
import io.grpc.ServerBuilder;
import io.grpc.stub.StreamObserver;
import java.io.IOException;
import org.bcosliteclient.demoDataTransaction;
public class UserServer {
    private Server server;
    public void start() throws IOException {
        /* The port on which the server should run */
        int port = 1330;
        server = ServerBuilder.forPort(port)
                .addService(new UserServer.CreateAccountImpl())
                .build()
                .start();
        Runtime.getRuntime().addShutdownHook(new Thread(() -&amp;gt; {
            // Use stderr here since the logger may have been reset by its JVM shutdown hook.
            System.err.println(&#34;*** shutting down gRPC server since JVM is shutting down&#34;);
            UserServer.this.stop();
            System.err.println(&#34;*** server shut down&#34;);
        }));
    }
    private void stop() {
        if (server != null) {
            server.shutdown();
        }
    }
    /**
     * Await termination on the main thread since the grpc library uses daemon threads.
     */
    public void blockUntilShutdown() throws InterruptedException {
        if (server != null) {
            server.awaitTermination();
        }
    }
    /**
     * Main launches the server from the command line.
     */
    public static void main(String[] args) throws IOException, InterruptedException {
        final UserServer server = new UserServer();
        server.start();
        server.blockUntilShutdown();
    }
    static class CreateAccountImpl extends CreateAccountGrpc.CreateAccountImplBase {
        @Override
        public void createAccount(User.CreateAccountRequest req, StreamObserver&amp;lt;User.CreateRequestResponse&amp;gt; responseObserver) {
            //System.out.println(req.getUid());
            String value ;
            if (req.getService().equals(&#34;Register&#34;)) {
                try {
                    value = &#34;Register&#34;;
                } catch (Exception e) {
                    value = &#34;error&#34;;
                    e.printStackTrace();
                }
            } else if (req.getService().equals(&#34;TokenQuery&#34;)) {
                try {
                    value = &#34;TokenQuery&#34;;
                } catch (Exception e) {
                    value = &#34;error&#34;;
                    e.printStackTrace();
                }
            } else {
                value = &#34;error&#34;;
            }
            User.CreateRequestResponse response = User.CreateRequestResponse.newBuilder().setValue(value).build();
            responseObserver.onNext(response);
            responseObserver.onCompleted();
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先运行 server 端监听端口，再运行客户端发送信息，可在控制台看到输出。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java GRPC proto 编译</title>
      <link>https://www.wingsxdu.com/p1216/</link>
      <pubDate>Thu, 23 May 2019 06:04:45 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1216/</guid>
      
        <description>

&lt;p&gt;相较于Go，Java 中的使用步骤就繁琐了很多，我也是折腾了很久才搞清楚。、&lt;/p&gt;

&lt;h5 id=&#34;环境&#34;&gt;环境&lt;/h5&gt;

&lt;p&gt;ubuntu 16.04&lt;/p&gt;

&lt;p&gt;IDE：Intellig IDEA&lt;/p&gt;

&lt;p&gt;Java 编译：Gradle&lt;/p&gt;

&lt;h5 id=&#34;proto-编译&#34;&gt;proto 编译&lt;/h5&gt;

&lt;p&gt;使用 Gradle 新建工程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/java-gradle-newproject-1-1.png&#34; alt=&#34;&#34; width=&#34;1058&#34; height=&#34;720&#34; class=&#34;size-full wp-image-1218 aligncenter&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其他的随便填，我们只用这个工程编译 proto，和工作工程分开操作&lt;/p&gt;

&lt;h6 id=&#34;build-gradle-配置&#34;&gt;build.gradle 配置&lt;/h6&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;java&#34;&gt;apply plugin: &#39;java&#39;
apply plugin: &#39;com.google.protobuf&#39;
apply plugin: &#39;idea&#39;
repositories {
    maven { url &#34;https://maven.aliyun.com/repository/central/&#34; }
}
dependencies {
    compile &#34;io.grpc:grpc-netty:1.20.0&#34;
    compile &#34;io.grpc:grpc-protobuf:1.20.0&#34;
    compile &#34;io.grpc:grpc-stub:1.20.0&#34;
}
buildscript {
    repositories {
        maven { url &#34;https://maven.aliyun.com/repository/central/&#34; }
    }
    dependencies {
        classpath &#39;com.google.protobuf:protobuf-gradle-plugin:0.8.8&#39;
    }
}
protobuf {
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.7.1&#39;
    }
    plugins {
        grpc {
            artifact = &#39;io.grpc:protoc-gen-grpc-java:1.20.0&#39;
        }
    }
    generateProtoTasks {
        ofSourceSet(&#39;main&#39;)*.plugins {
            grpc { }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grpc-java 版本信息查看：&lt;a href=&#34;https://github.com/grpc/grpc-java&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;a href=&#34;https://github.com/grpc/grpc-java&#34;&gt;https://github.com/grpc/grpc-java&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;protobuf-gradle-plugin 版本信息查看：&lt;a href=&#34;https://plugins.gradle.org/plugin/com.google.protobuf&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;a href=&#34;https://plugins.gradle.org/plugin/com.google.protobuf&#34;&gt;https://plugins.gradle.org/plugin/com.google.protobuf&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;protoc 版本信息查看：在命令行输入：&lt;code class=&#34;bash&#34;&gt;protoc &amp;ndash;version&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/ubuntu-proto-version-1.png&#34; alt=&#34;&#34; width=&#34;737&#34; height=&#34;216&#34; class=&#34;aligncenter size-full wp-image-1219&#34; /&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/ubuntu-proto-version-1-1.png&#34; alt=&#34;&#34; width=&#34;737&#34; height=&#34;216&#34; class=&#34;size-full wp-image-1219 aligncenter&#34; /&gt;&lt;/p&gt;

&lt;p&gt;将 user.proto 文件复制到 src/main/proto文件夹下，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/java-proto-1.png&#34; alt=&#34;&#34; width=&#34;1343&#34; height=&#34;525&#34; class=&#34;aligncenter size-full wp-image-1221&#34; /&gt;&lt;/p&gt;

&lt;p&gt;右键 user.proto，选择 Recompile&amp;#8221;user.proto&amp;#8221;（第一次编译可能是compile)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/java-proto-1-build-1-1.png&#34; alt=&#34;&#34; width=&#34;270&#34; height=&#34;300&#34; class=&#34;size-medium wp-image-1222 aligncenter&#34; /&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/java-proto-build-1.png&#34; alt=&#34;&#34; width=&#34;716&#34; height=&#34;797&#34; class=&#34;aligncenter size-full wp-image-1222&#34; /&gt;编译完成后会在 build 目录内生成 grpc和 java 文件夹，将目录内的文件复制到工程内。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/java-proto-get-1.png&#34; alt=&#34;&#34; width=&#34;677&#34; height=&#34;737&#34; class=&#34;aligncenter size-full wp-image-1223&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/java-proto-1-get-1-1.png&#34; alt=&#34;&#34; width=&#34;677&#34; height=&#34;737&#34; class=&#34;size-full wp-image-1223 aligncenter&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Go GRPC使用</title>
      <link>https://www.wingsxdu.com/p1204/</link>
      <pubDate>Wed, 22 May 2019 11:59:06 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1204/</guid>
      
        <description>

&lt;h5 id=&#34;1-1rpc简介&#34;&gt;1.1RPC简介&lt;/h5&gt;

&lt;p&gt;&lt;span&gt;RPC，全称 Remote Procedure Call——远程过程调用，主要用于分布式系统中程序间的通信，基于 TCP 或 UDP 传输协议实现。RPC 属于 IPC（进程间通信）的分支，除 RPC 外还有共享内存、channel 等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;GRPC 是谷歌开源的一个高性能、跨语言的 RPC 框架，基于 HTTP2 、Protobuf 和 Netty 4.x ; GRPC 的优势不在于性能，而是跨语言，还和 Golang 有同一个爹。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;GRPC 官网：&lt;a href=&#34;https://grpc.io/&#34;&gt;https://grpc.io/&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;1-2-protobuf-简介&#34;&gt;1.2  Protobuf 简介&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Google Protocol Buffer(简称 Protobuf)是一种轻便高效的结构化数据存储格式，平台无关、语言无关、可扩展，可用于通讯协议和数据存储等领域。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简言之，这是一种跨语言的结构化数据存储格式，类似于 JSON&lt;/p&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://developers.google.cn/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;a href=&#34;https://developers.google.cn/protocol-buffers/docs/proto3&#34;&gt;https://developers.google.cn/protocol-buffers/docs/proto3&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;中文文档：&lt;a href=&#34;http://doc.oschina.net/grpc?t=56831&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;a href=&#34;http://doc.oschina.net/grpc?t=56831&#34;&gt;http://doc.oschina.net/grpc?t=56831&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;1-2-环境配置&#34;&gt;1.2 环境配置&lt;/h5&gt;

&lt;p&gt;工作环境：ubuntu 16.04&lt;/p&gt;

&lt;h6 id=&#34;protobuf-安装&#34;&gt;protobuf 安装&lt;/h6&gt;

&lt;p&gt;官方教程：&lt;a href=&#34;https://github.com/protocolbuffers/protobuf/blob/master/src/README.md&#34;&gt;https://github.com/protocolbuffers/protobuf/blob/master/src/README.md&lt;/a&gt;&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;bash&#34;&gt;$ sudo apt-get install autoconf automake libtool curl make g++ unzip
$ git clone https://github.com/google/protobuf.git
$ cd protobuf
$ git submodule update --init --recursive
$ ./autogen.sh
$ ./configure
$ make
$ make check
$ sudo make install
$ sudo ldconfig # refresh shared library cache.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后输入：protoc &amp;#8211;version 查看版本信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.wingsxdu.com/wp-content/uploads/2019/05/ubuntu-proto-version-1-1.png&#34; alt=&#34;&#34; width=&#34;737&#34; height=&#34;216&#34; class=&#34;alignnone size-full wp-image-1219&#34; /&gt;&lt;/p&gt;

&lt;h6 id=&#34;go语言-protobuf-编译&#34;&gt;Go语言 Protobuf 编译&lt;/h6&gt;

&lt;p&gt;Go语言版 grpc下载：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;$ go get -u google.golang.org/grpc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若由于网络问题无法下载，使用 github 镜像再将包移动到 google.golang.org：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;$ go get -u github.com/grpc/grpc-go&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go语言 proto 编译环境：&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;$ go get -u github.com/golang/protobuf/protoc-gen-go&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理&amp;#8230;使用了很多 golang.org/ 包，镜像下载参考：&lt;a href=&#34;https://www.wingsxdu.com/?p=1095&#34;&gt;Go 下载包 golang.org/x/&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;1-3实战使用&#34;&gt;1.3实战使用&lt;/h5&gt;

&lt;h6 id=&#34;定义-proto&#34;&gt;定义 proto&lt;/h6&gt;

&lt;p&gt;新建 user.proto 文件&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;syntax = &#34;proto3&#34;; //Protocol Buffers Version
//定义的service
service CreateAccount{
    rpc CreateAccount(CreateAccountRequest) returns (CreateRequestResponse){}
}
//请求的结构体
message CreateAccountRequest{
    string uid = 1;
    string service = 2;
}
//返回的结构体
message CreateRequestResponse{
    string value = 1;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译 Go 源码，生成user.pb.go（将package user改为 hello)&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;$ protoc --go_out=plugins=grpc:. hello.proto&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;go-客户端&#34;&gt;Go 客户端&lt;/h6&gt;

&lt;p&gt;新建userClient.go&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;func CreateAccount(uid string, service string) (value string, err error){
    conn, err := grpc.Dial(&#34;localhost:1330&#34;, grpc.WithInsecure())
    if err != nil {
        fmt.Println(err)
        return &#34;error&#34;, err
    }
    defer conn.Close()
    client := hello.NewCreateAccountClient(conn)
    Value, err := client.CreateAccount(context.Background(), &amp;hello.CreateAccountRequest{Uid:uid,Service:service})
    if err != nil {
        fmt.Println(err)
        return &#34;error&#34;, err
    }
    return Value.Value,nil
}&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;go服务端&#34;&gt;Go服务端&lt;/h6&gt;

&lt;p&gt;新建userServer.go&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;type server struct{}
func (s *server) CreateAccount(ctx context.Context,response *hello.CreateAccountRequest) (*hello.CreateRequestResponse, error){
    fmt.Println(response.Uid+response.Service)
    return &amp;hello.CreateRequestResponse{Value:&#34;hello =======&amp;gt; &#34; + response.Uid},nil
}
func main(){
    lis,err := net.Listen(&#34;tcp&#34;,&#34;1330&#34;)
    if err != nil {
        log.Fatal(&#34;fail to listen&#34;)
    }
    s := grpc.NewServer()
    hello.RegisterCreateAccountServer(s,&amp;server{})
    reflection.Register(s)
    if err:= s.Serve(lis);err != nil{
        log.Fatal(&#34;fail to server&#34;)
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;调用&#34;&gt;调用&lt;/h6&gt;

&lt;p&gt;开启 server 端保持监听端口1330状态，调用&lt;code class=&#34;null&#34;&gt;CreateAccount()&lt;/code&gt;函数传值即可。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>密码保护：前台接口定义</title>
      <link>https://www.wingsxdu.com/p1188/</link>
      <pubDate>Tue, 21 May 2019 10:01:49 +0000</pubDate>
      
      <guid>https://www.wingsxdu.com/p1188/</guid>
      
        <description>

&lt;h5 id=&#34;前言说明&#34;&gt;前言说明&lt;/h5&gt;

&lt;p&gt;url路径：&lt;code class=&#34;http&#34;&gt;&lt;a href=&#34;https://star.wingsxdu.com&#34;&gt;https://star.wingsxdu.com&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如路由为：/login，完整的 uri 为：&lt;code class=&#34;http&#34;&gt;&lt;a href=&#34;https://star.wingsxdu.com/login&#34;&gt;https://star.wingsxdu.com/login&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;String 返回值均已改成JSON。&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;专有名词&#34;&gt;&lt;strong&gt;专有名词&lt;/strong&gt;&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code class=&#34;null&#34;&gt;Content-Type:application/form-data&lt;/code&gt;与&lt;code class=&#34;null&#34;&gt;Content-Type:application/x-www-form-urlencoded&lt;/code&gt;后台均可解析，二选一，文档统一用&lt;code class=&#34;null&#34;&gt;form-data&lt;/code&gt;代替；&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;uid//用户唯一标识id，长度最大为20
password//用户密码
username//用户名，长度最大为25
code//微信登录获取的临时
code itemname//商品名称
description//描述
tag//标签
value//商品价格
file//用户选择的图片
Itemhash//商品hash，唯一值 Ext//商品的扩展名，如：&#34;.docx&#34;、&#34;.jpg&#34;
Transactionhash//商品记录在区块链上得到的记录id
from//买家uid
to//卖家即商品所有者的uid
txId//订单号
Mold//交易类型，默认值为0，增值服务为1（type为golang 关键字，无法使用）&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;已知bug&#34;&gt;&lt;strong&gt;已知Bug&lt;/strong&gt;&lt;/h6&gt;

&lt;p&gt;&lt;strong&gt;Web 端：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若 get 方法存在 header，无法执行跨域请求，请在header 内添加字段&lt;code class=&#34;null&#34;&gt;Content-Type:application/form-data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;注册登录组&#34;&gt;注册登录组&lt;/h5&gt;

&lt;p&gt;注册&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/register
方式：post
header:{
    Content-Type:application/form-data
}
body:{
    uid:
    password:
    username:
}
返回值：{
    成功：return c.JSONPretty(http.StatusOK, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;balance&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;注册成功,账户资金为：} )
    失败：return c.JSONPretty(http.StatusInternalServerError, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:服务器可能出现内部错误} &amp;lt;/span&gt;)
    用户已存在：return c.JSONPretty(http.StatusOK, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;该用户已存在，请重新注册} )
    //解释：c.后面为返回值类型，如c.String返回值为String类型，c.JSON为JSON类型；
    //     http.StatusOK为返回的code,如200、404等，不用管；最后为返回值
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登录：平台方&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/login
方式：post
header:{
    Content-Type:application/form-data
}
body:{
    uid:
    password:
}
返回值{
成功：return c.JSONPretty(http.StatusOK, {token: t})//token值保存
密码错误：return c.JSONPretty(http.StatusOK, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;用户名或密码错误} )
错误：return c.JSONPretty(http.StatusInternalServerError, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;服务器可能出现内部错误} )
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登录：微信&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/login/wechat
方式：post
header:{
    Content-Type:application/form-data
}
body:{
    code:
}
返回值{
成功：return c.JSONPretty(http.StatusOK, {token: t,})//token值保存
错误：return c.JSONPretty(http.StatusInternalServerError, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;服务器可能出现内部错误} )
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;用户组&#34;&gt;用户组&lt;/h5&gt;

&lt;p&gt;获取用户信息&lt;/p&gt;

&lt;p&gt;更改用户昵称&lt;/p&gt;

&lt;p&gt;查询账户余额&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/user/balance
方式：get
header:{
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
返回值{
成功：return c.JSONPretty(http.StatusOK, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;balance&amp;lt;/span&gt;&amp;lt;span&gt;:value} &amp;lt;/span&gt;)
失败：return c.JSONPretty(http.StatusOK, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:服务器可能出现内部错误}&amp;lt;/span&gt;&amp;lt;span&gt; &amp;lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;搜索组&#34;&gt;搜索组&lt;/h5&gt;

&lt;p&gt;搜索&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/search/:kw //示例：search/用户输入的搜索词
方式：get
返回值{
成功：return c.JSONPretty(http.StatusOK, JSONArray )
无结果：return c.JSONPretty(http.StatusOK, &amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;无查询结果} )
}
&amp;lt;span&gt;数组字段：
[{
    Itemhash
    Itemname
    Description
    Tag
    Uid
    Value
    Ext
    Transactionhash
}]&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;缩略图组&#34;&gt;缩略图组&lt;/h5&gt;

&lt;p&gt;获取缩略图信息&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/thumbnail/list/:kw(暂用&#34;测试数据&#34;与&#34;背景&#34;两个字段)
方式：get
返回值{
成功：return c.JSONPretty(http.StatusOK, JSONArray,&#34;&#34;)
失败：return c.JSON(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;无查询结果} )
}
&amp;lt;span&gt;数组字段：
[{
    Itemhash
    Uid
    Ext
}]&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加载缩略图&lt;/p&gt;

&lt;p&gt;使用：解析上面获取的 json 数组，遍历加载数组内的 json 对象获取缩略图。&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/thumbnail?uid=uid&amp;itemhash=itemhash&amp;ext=ext
方式：get
返回值{
成功：return c.Inline(缩略图)//在浏览器加载显示
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;数据上传下载组&#34;&gt;数据上传下载组&lt;/h5&gt;

&lt;p&gt;数据上传&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/upload
方式：post
header:{
    Content-Type:application/form-data
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
body:{
    itemname://商品名称
    description://描述
    tag://标签
    value://
    file://用户选择的图片
}
返回值{
成功：return c.JSONPretty(http.StatusCreated,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;数据上传成功,唯一标识id为：} )
已上传：return c.JSONPretty(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;该数据已被上传，是否进行数据确权？} )
错误：return c.JSONPretty(http.StatusNotFound,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;文件上传失败，请检查网络或重新上传} )
           return c.JSONPretty(http.StatusInternalServerError,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;服务器可能出现内部错误} )
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载原图&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/download
方式：post
header:{
    Content-Type:application/form-data
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
body:{
    uid://商品所有者的用户id
    itemhash:
    ext:
}
返回值{
成功：return c.File(原图)//浏览器下载文件并保存
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;商品组&#34;&gt;商品组&lt;/h5&gt;

&lt;p&gt;获取商品详情&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/item/get/:ih
方式：get
header:{
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
返回值{
成功： return c.JSONPretty(http.StatusOK, JSONObject)
无查询结果：return c.JSONPretty(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;无查询结果} )
}
Json 对象字段
&amp;lt;span&gt;{
    Itemhash
    Itemname
    Description
    Tag
    Uid
    Value
    Ext
    Transactionhash
}&amp;lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确认商品是否存在&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/item/has/:ih
方式：get
header:{
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
返回值{
成功： return c.JSONPretty(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;该数据确认存在} )
无查询结果：return c.JSONPretty(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;无查询结果} )
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除商品（下架）&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/item/delete/:ih
方式：get
header:{
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
返回值{
成功：return c.JSONPretty(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;数据删除成功} )
失败：return c.JSONPretty(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;删除失败，确认数据哈希值是否正确} )
操作账户与所有者不匹配：return c.JSONPretty(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:&amp;lt;/span&gt;您不是该商品的所有者} )
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新商品信息&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/item/update
方式：post
header:{
    Content-Type:multipart/form-data
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
body:{
    itemhash://必填字段
    itemname:
    value:
    description:
    tag:
}
返回值{
成功：return c.JSONPretty(http.StatusOK, {result:更新成功},&#34;&#34;)
失败：return c.JSONPretty(http.StatusOK, {result:更新失败，请稍后重试},&#34;&#34;)
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;交易组&#34;&gt;交易组&lt;/h5&gt;

&lt;p&gt;交易&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/trade
方式：post
header:{
    Content-Type:multipart/form-data
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
body:{
    to://卖家即商品所有者的uid
    value://价格
    itemhash:
    mold://交易类型，默认值为0
}
返回值{
成功：return c.JSONPretty(http.StatusOK, &amp;lt;span&gt;{TxId&amp;lt;/span&gt;&amp;lt;span&gt;:订单号} &amp;lt;/span&gt;)
失败：return c.JSONPretty(http.StatusOK,&amp;lt;span&gt; &amp;lt;/span&gt;&amp;lt;span&gt;{&amp;lt;/span&gt;&amp;lt;span class=&#34;hljs-keyword&#34;&gt;result&amp;lt;/span&gt;&amp;lt;span&gt;:交易失败} &amp;lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;退款&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/trade/refund
方式：post
header:{
    Content-Type:multipart/form-data
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
body:{
    from://买家uid
    to://卖家即商品所有者的uid
    txId://订单号
}
返回值{
成功：return c.JSONPretty(http.StatusOK, {result:退款成功} )
失败：return c.JSONPretty(http.StatusOK, {result:退款失败，请检查订单号} )
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询订单信息&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/trade/txinfo
方式：post
header:{
    Content-Type:multipart/form-data
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
body:{
    txId://订单号
}
返回值{
成功：return c.JSONPretty(http.StatusOK, {result:交易信息详情} )
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;买家订单查询&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/trade/fromlist
方式：get
header:{
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
返回值{
成功：return c.JSONPretty(http.StatusOK, JsonArray)
失败：return c.JSONPretty(http.StatusOK, {result:无查询结果} )
}
数组字段：
[{
    From
    To
    Value
    ItemHash
    Mold
    TxId
}]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;卖价家订单查询&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/trade/tolist
其他同上&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;应付组&#34;&gt;应付组&lt;/h5&gt;

&lt;p&gt;数据信息上链&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/watermark/add
方式：post
header:{
    Content-Type:application/form-data
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
body:{
    itemhash//商品hash
    message//水印信息
}
返回值{
成功：return c.JSONPretty(http.StatusCreated, JsonArray )
数组字段：
[{
has:bool
TxId
}]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据TxId查询&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/restricted/watermark/get
方式：post
header:{
    Content-Type:application/form-data
    Authorization:Bearer +登录获取的token值//注意Bearer与token值之间有一个空格
}
body:{
    TxId
}
返回值{
成功：return c.JSONPretty(http.StatusCreated, JsonArray )
数组字段：
[{
uid
itemhash
message
time
}]&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;wsl&#34;&gt;WSL&lt;/h5&gt;

&lt;p&gt;上传图片&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/upload
方式：post
header:{
    Content-Type:application/form-data
}
body:{
    file://选择的图片
}
返回值{
成功：return c.JSONPretty(http.StatusCreated, {result:success} )
错误：return c.JSONPretty(http.StatusNotFound, {result:文件上传失败，请检查网络或重新上传} )
           return c.JSONPretty(http.StatusInternalServerError, {result:服务器可能出现内部错误} )
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编码&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/decode
方式：post
header:{
    Content-Type:application/form-data
}
body:{
    filename://商品名称
    txid//交易hash
}
返回值{
成功：return c.File({temp.png} )
错误：return c.JSONPretty(http.StatusNotFound, {result:error()} )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解码&lt;/p&gt;

&lt;pre class=&#34;pure-highlightjs&#34;&gt;&lt;code class=&#34;null&#34;&gt;路由：/decode
方式：post
header:{
    Content-Type:application/form-data
}
body:{
    filename://商品名称
}
返回值{
成功：return c.JSON(http.StatusOK, {result:图片解码得到的信息})
错误：return c.JSONPretty(http.StatusNotFound, {result:error()} )&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
