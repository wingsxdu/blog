---
author: "beihai"
title: "Go 语言内存管理"
description: "Golang GC 时会发生什么"
tags: [
    "Golang",
    "实现原理",
    "底层",
]
categories: [
    "Golang",
]
date: 2019-09-27T21:42:49+08:00
draft: false
---

内存管理是开发应用中的一大难题。传统的系统级编程语言（主要指 C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。

<!--more-->

## 过去常采用的两种内存管理方法

#### 内存泄露检测工具

这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然而检测工具难免有疏漏和不足，只能起到辅助作用。

#### 智能指针

这是 C++ 中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，使程序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是最广泛的做法，但是对程序开发者有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄露。

为了解决这个问题，后来开发出来的很多新语言都引入了语言层面的自动内存管理 ——也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。

## 新生代语言常用的垃圾回收的方法

#### 引用计数（Reference Counting）

这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一，当引用计数为 0 时则立即回收对象。

这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如 ios cocoa 框架、php、python 等。

但是简单引用计数算法也有明显的缺点：

- 频繁更新引用计数降低了性能：一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。除此之外还有很多其他方法。

- 循环引用：当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如 cocoa 引入了 strong 指针和 weak 指针两种指针类型。或者系统检测循环引用并主动打破循环链，当然这也增加了垃圾回收的复杂度。

#### 标记-清除（Mark And Sweep）

标记-清除（Mark And Sweep）分为两步，标记从根变量开始迭代遍历所有被引用的对象，对能够通过引用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行(Stop the  World)，回收使系统响应能力大大降低。当然后续也出现了很多 mark&sweep 算法的变种（如三色标记法）优化了这个问题。

#### 分代搜集（Generation）

Java 的 jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（Generation）的空间。新创建的对象存放在称为新生代（Young Generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升到老年代中.

因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。

## Golang GC

> Golang 1.5后，采取的是**非分代的、非移动的、并发的、三色的**标记清除垃圾回收算法。
>

在Go 1.5 后采用的三色标记算法，是对标记-清除算法的改进。

当垃圾回收器第⼀次启动的时候，它把所有的对象都看成⽩⾊的，如果这个对象引⽤了另外⼀个对象，那么被引⽤的对象称之为灰⾊的，把灰⾊的放⼊⼀个队列⾥去，那么当它第⼀次扫描完了以后这个⽆⾮就是变成两种状态，⽩⾊的和灰⾊的，⽩⾊的不属于我们要管的。

![img](index.assets/mark_sweep_5.png)

gc开始：扫描所有可到达的对象，标记为灰色

![img](index.assets/mark_sweep_6.png)

从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色

![img](index.assets/mark_sweep_7.png)

监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在

![img](index.assets/mark_sweep_8.png)

此时，gc回收白色对象。

![img](index.assets/mark_sweep_9.png)

最后，将所有黑色对象变为白色，并重复以上所有过程。

![img](index.assets/mark_sweep_10.png)

GC 的过程一共分为四个阶段：

1. 栈扫描（开始时 STW）
2. 第一次标记（并发）
3. 第二次标记（STW）
4. 清除（并发）

整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。

1. 先 STW(Stop-The-World) 做一些准备工作，比如打开写屏障。然后取消 STW，将扫描任务作为多个并发的 Goroutine 立即入队给调度器，进而被 CPU 处理；
2. 第一轮先扫描 root 对象，包括全局指针和 Goroutine 栈上的指针，标记为灰色放入队列;
3. 第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象；
4. 第三轮再次 STW，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了写屏障记录。

Golang GC 优化的核心就是尽量使得 STW(Stop The World) 的时间越来越短。

详细的Golang的GC介绍可以参看[Golang垃圾回收](https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/spec/02.0.md)。

#### 内存优化

通常小对象过多会导致 GC 三色法消耗过多的GPU。在编程过程中，尽可能减少对象分配，如使用结构体变量、减少值传递等。

