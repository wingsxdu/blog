---
title: "并发编程与 Goroutine 调度"
author: "beihai"
description: "DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING."
tags: [
    "技术向",
    "golang",
    "底层",
]
categories: [
    "技术向",
    "golang",
    "底层",
]
toc: true
date: 2019-09-29T17:20:37+08:00
draft: false
---

#### 并发与并行

并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生。

并行是在不同实体上的多个事件，在多台处理器上同时处理多个任务。并发是在同一实体上的多个事件,在一台处理器上“同时”处理多个任务。

并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。

并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

#### 协程，线程，进程的区别。

- 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

- 线程

线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间主要通过共享内存通信，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

- 协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，因为是直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

#### Goroutine 调度

> DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING.
> “不要通过共享内存来通信，而应通过通信来共享内存。”

###### Goroutine

Goroutine，Go语言基于并发（并行）编程给出的解决方案。通常 goroutine 会被当做 coroutine（协程）的 golang 实现，从比较粗浅的层面来看，这种认知也算是合理。但实际上，goroutine并非传统意义上的协程，现在主流的线程模型分三种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），传统的协程库属于**用户级线程模型**，而 goroutine 和它的`Go Scheduler`在底层实现上其实是属于**两级线程模型**，因此，有时候为了方便理解可以简单把goroutine类比成协程，但一定要有个清晰的认知——goroutine并不等同于协程。

goroutine使用方式非常的简单，只需使用 `go` 关键字即可启动一个协程，并且它是处于异步方式运行，你不需要等它运行完成以后在执行以后的代码。

`go func() // 通过go关键字启动一个协程来运行函数`

Go的调度器内部有四个重要的结构：M，P，S，Sched，如上图所示（Sched 未给出）。

- G：表示 Goroutine，每个 Goroutine 对应一个G结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个 G 需要绑定到 P 才能被调度执行。
- P： Processor，表示逻辑处理器。 对G来说，P 相当于 CPU 核，G 只有绑定到 P （在 P 的 local  队列中）才能被调度。对 M 来说，P 提供了相关的执行环境（Context），如内存分配状态（mcache），任务队列（G）等， P的数量决定了系统内最大可并行的 G 的数量（前提：物理CPU核数 >= P 的数量），P 的数量由用户设置的 GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P的数量最大为256。
- M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为10000个。
- Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。

![goroutine1](https://www.wingsxdu.com/image/goroutine1.jpg)

###### G-P-M 模型调度

![goroutine-scheduler-model](https://www.wingsxdu.com/image/goroutine-scheduler-model.png)

Go 调度器工作时会维护两种用来保存 G 的任务队列：一种是一个 Global 任务队列，一种是每个 P 维护的 Local 任务队列。

当通过` go `关键字创建一个新的 goroutine 的时候，它会优先被放入P 的本地队列。为了运行goroutine，M 需要持有（绑定）一个 P，接着M会启动一个 OS线程，循环从P的本地队列里取出一个 goroutine 并执行。

![](https://www.wingsxdu.com/image/goroutine2.jpg)

从上图中可以看到，有2个物理线程M，每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。

除此之外还有 ` work-stealing `调度算法：当 M 执行完了当前 P 的 Local 队列里的所有 G 后，P 也不会就这么在那躺尸啥都不干，它会先尝试从 Global 队列寻找 G 来执行，如果 Global队列为空，它会随机挑选另外一个 P，从它的队列里中拿走一半的 G 到自己的队列中执行。

![](https://www.wingsxdu.com/image/goroutine3.jpg)

#### 为什么要有 P(Processor) ？

你可能会想，为什么一定需要一个上下文，我们能不能直接除去上下文，让 `Goroutine` 的 `runqueues` 挂到M上呢？答案是不行，需要上下文的目的，是让我们可以直接放开其他线程，当遇到内核线程阻塞的时候。

一个很简单的例子就是系统调用 `sysall`，一个线程肯定不能同时执行代码和系统调用被阻塞，这个时候，此线程M需要放弃当前的上下文环境 P，以便可以让其他的 `Goroutine` 被调度执行。