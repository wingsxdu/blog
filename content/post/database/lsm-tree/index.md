---
title: ZooKeeper 与 Zab 协议 · Analyze
author: beihai
summary: "<blockquote><p>etcd 是由 CoreOS 发起的开源项目，旨在构建一个高可用的分布式键值存储系统。etcd 可以用于存储关键数据和实现分布式调度，在现代化的集群运行中起到关键性的作用。</p></blockquote>"
tags: [
    "Leveldb",
    "LSM-Tree",
]
categories: [
    "Analyze",
    "Leveldb",
	"数据库",
	"存储引擎",
]
date: 2020-07-07T12:05:03+08:00
draft: false

---

> 













对于任何应用来说，那些会导致索引值发生变化（比如一条记录包含了ID和name，同时是以ID进行索引的，那么如果是name更新了，很容易，只需要对该记录进行一个原地改动即可，但是如果是ID该了，那么该记录在索引中的位置就要调整了，因此是很棘手的）的更新都是不平凡的，但是这样的更新却可以被LSM-tree一招化解，通过将该更新操作看做是一个删除操作加上一个插入操作。



但是在一个LSM-tree中，只要与C1组件相比C0组件足够大，总是会有一个批量处理效果。比如，对于16字节的索引记录大小来说，在一个4Kbytes的节点中将会有250条记录。如果C0组件的大小是C1的1/25，那么在每个具有250条记录的C1节点的Node IO中，将会有10条是新记录{!也就是说在此次merge产生个node中有10条是在C0中的，而C0中的记录则是用户之前插入的，这相当于将用户的插入先暂存到C0中，然后延迟到merge时写入磁盘，这样这一次的Node IO实际上消化了用户之前的10次插入，的确是将插入批量化了}。很明显，由于这两个因素，与B-树相比LSM-tree效率更高，而rolling merge过程则是其中的关键。