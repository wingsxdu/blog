---
title: "Redis 如何在“单线程”下实现高性能 · Why"
author: "beihai"
summary: "<blockquote><p>Redis 一直以高性能著称，然而 Redis 却是以单线程运行的，这通常与人们的认知相悖。那么 Redis 采用了哪些机制来保证巨大的处理量需求？如何在“单线程”下实现高性能，这是这篇文章主要探讨的问题。</p></blockquote>"
tags: [
    "Analyze",
    "数据库",
    "Redis",
]
categories: [
    "Analyze",
	"数据库",
	"Redis",
]
date: 2020-02-26T22:51:33+08:00
draft: false
---

> 对 Redis 数据库的源码阅读，当前版本为 Redis 6.0 RC1，参考书籍《Redis 设计与实现》及其注释。项目地址：[github.com/wingsxdu](https://github.com/wingsxdu/redis)

Redis 一直以高性能著称，然而 Redis 却是以单线程运行的，这通常与人们的认知相悖。那么 Redis 采用了哪些机制来保证巨大的处理量需求？如何在“单线程”下实现高性能，这是这篇文章主要探讨的问题。

标题中“单线程”一词加了引号，这是因为 Redis 的单线程指的是处理网络请求模块使用了一个线程，采用了线程封闭概念，把任务封闭在一个线程中，避免了多线程安全问题。Redis 在运行时用一个线程处理所有网络请求，其他模块仍用了多个线程。

那么 Redis 在哪些模块使用了多线程处理？

## 单线程优势

使用多线程往往可以获得更大的吞吐率和更短的响应时间，但是，使用多线程不一定比单线程程序快。CPU 在一个时间片内只执行一个线程，当内核线程切换时，需要保存线程 A 的执行上下文，然后加载线程 B 的执行上下文，其中涉及的寄存器包括：

> 16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.

线程进行上下文切换的开销并不低，如果没有必要，应该尽量减少上下文切换的发生。而且采用多线程往往使得设计更复杂，在访问共享数据时，需要我们更小心地处理——对数据加锁，对 Redis 来说并不是一个划算的选择。

另一方面，Redis 的绝大部分请求是纯粹的内存操作，这一过程非常快速，CPU 并不会成为性能瓶颈，即使采用单线程一台实例每秒也可以处理数万的数据请求。如果有更高的并发量需求，Redis 还支持集群部署，在一台或多台服务器上启动多个实例，分摊访问压力。

因为 Redis 并不是 CPU 密集型的程序，采用单线程足以满足运算需求，避免了不必要的上下文切换和数据竞争，运行也更加稳定。既然性能足够，就无需过度设计引入多线程。

## I/O 复用

Unix 系统下包含五种可用的 I/O 模型，分别是：阻塞 I/O、非阻塞 I/O、I/O 复用、信号 I/O 与异步 I/O。当客户端发起通信时，服务端通常包括两个不同的阶段：

1. 等待数据从网络中达到，当等待分组到达时，它将会被复制到内核中的某个缓冲区；
2. 将数据从内核缓冲区复制到应用进程缓冲区中。

阻塞 I/O 是最流行的 I/O 模型，默认情形下，对文件和网络套接字的读写都是阻塞的，当进程调用`read`或者`recvfrom`等系统调用读写 FD 时，应用进程会因此阻塞。如下图所示，应用程序会从用户态切换到内核态，内核检查对应的文件描述符是否准备就绪，当操作系统内核将数据复制给应用进程后，再从内核态切换到用户态，应用进程继续执行。



由于线程的执行过程是线性的，当我们对阻塞 I/O 调用`read`时，进程就会陷入等待直到 I/O 操作结束，在这期间不能执行其他操作。

当进程把一个套接字设置成非阻塞时，执行`read`等 I/O 操作内核会立即返回。如果套接字还未准备就绪，内核会返回一个`EWOULDBLOCK`错误，由于进程未接收到数据，会发起轮询操作，不断调用 I/O 函数，直至内核返回成功。

进程使用非阻塞 I/O 时可以在等待期间执行其它的任务，但是轮询操作会消耗一定的 CPU 资源。





## 耗时任务处理



Redis 是一个事件驱动的程序，将客户端命令、定时任务抽象为事件，交由对应的事件处理器执行。事件的处理全部在一个线程内顺序执行，没有其他的线程参与。但在某些情况下，Redis 可能会创建新的线程：

- Redis 在生成 RDB 快照时会`fork`出一个子进程将内存数据写入磁盘；
- Redis4.0 中引入`UNLINK`命令，当使用`UNLINK`命令删除的键较大时，Redis 会将 key 从键空间中删除，而 value 的删除则交由后台线程处理；
- Redis6.0 开始支持 I/O 多线程，服务端与客户端通信是一个耗时操作，主线程将处理后的数据交给 I/O 线程，由 I/O 线程发送给客户端。

Redis 一直在优化多任务处理能力，以充分利用多核处理器，从上面的举例可以看出，Redis 主要针对一些耗时操作，如数据备份、删除大键值对（如十几MB的哈希表）、I/O 通信等进行多线程（进程）优化，节约主线程的计算压力。而且这些被排出主线程的的操作与对客户端命令的执行几乎没有影响，

## 总结

